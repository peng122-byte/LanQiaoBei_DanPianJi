C51 COMPILER V9.59.0.0   MAIN                                                              01/24/2026 21:19:36 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keilc51\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* 头文件声明区 */
   2          #include <REGX52.H>//单片机寄存器专用头文件
   3          #include <Key.h>//按键底层驱动专用头文件
   4          #include <Seg.h>//数码管底层驱动专用头文件
   5          #include <intrins.h>
   6          #include <Led.h>
   7          /* 变量声明区 */
   8          unsigned char Key_Val,Key_Down,Key_Old,Key_Up;//按键专用变量
   9          unsigned char Key_Slow_Down;//按键减速专用变量
  10          unsigned int Key4_Press_Time;//按键4长按计数器
  11          bit Key4_Long_Pressed;//按键4长按标志,防止重复触发
  12          unsigned char Seg_Buf[6] = {10,10,10,10,10,10};//数码管显示数据存放数组
  13          unsigned char Seg_Point[6] = {0,0,0,0,0,0};//数码管小数点数据存放数组
  14          unsigned char Seg_Pos;//数码管扫描专用变量
  15          unsigned int Seg_Slow_Down;//数码管减速专用变量
  16          unsigned char Led_Mod ;//Led模式 0-模式一：从左到右 1-模式二：从右到左 2-模式三 3-模
             -式四
  17          unsigned char Led_Num,Led_Old;//Led编号
  18          unsigned char Led_Num1,Led_Old1;
  19          unsigned char Led_Num2,Led_Old2,Led_Num2s,Led_Old2s;
  20          unsigned char Led_Num3,Led_Old3,Led_Num3s,Led_Old3s;
  21          unsigned int Time[9] = {400,500,600,700,800,900,1000,1100,1200};//流转时间数组
  22          unsigned char Time_Index;//流转时间数组索引
  23          bit System_Flag ;//系统标志位
  24          unsigned int Led_Set_Data [4] = {400,400,400,400};//各模式流转时间
  25          unsigned int Led_Data [4] = {400,400,400,400};//各模式流转时间
  26          unsigned int System_Tick;//流转时间计数
  27          unsigned char Set_Mod;//模式变量
  28          bit Setting;//模式标志位
  29          unsigned char State[3] = {11,12,13};//S A -
  30          unsigned char Mod_Set;//模式设置
  31          unsigned int Setting_Tick;//设置模式时间计数
  32          bit Setting_Flag;//设置模式闪烁
  33          bit DA_Disp;
  34          unsigned char Led_Sum1;
  35          unsigned char Led_Sum2;
  36          /* 键盘处理函数 */
  37          void Key_Proc()
  38          {
  39   1        if (Key_Slow_Down) return;
  40   1        Key_Slow_Down = 1;//按键减速程序
  41   1        Key_Val = Key_Read();//读取按下的键值
  42   1        Key_Down = Key_Val & (Key_Val ^ Key_Old);//下降沿
  43   1        Key_Up = Key_Old & (Key_Val ^ Key_Old);//上升沿
  44   1        Key_Old = Key_Val;//辅助扫描
  45   1      
  46   1        //按键4长按检测(1秒=100次扫描)
  47   1        if((Key_Old == 4) && (System_Flag == 0))
  48   1        {
  49   2          if(++Key4_Press_Time >= 100 && Key4_Long_Pressed == 0)
  50   2          {
  51   3            DA_Disp ^= 1;//切换到数据显示界面
  52   3            Key4_Long_Pressed = 1;//防止重复触发
  53   3          }
C51 COMPILER V9.59.0.0   MAIN                                                              01/24/2026 21:19:36 PAGE 2   

  54   2        }
  55   1        else
  56   1        {
  57   2          Key4_Press_Time = 0;//松开或其他情况清零计数
  58   2          Key4_Long_Pressed = 0;//清除长按标志
  59   2        }
  60   1      
  61   1        switch(Key_Down)
  62   1        {
  63   2          case 7:
  64   2            System_Flag ^= 1;
  65   2          break;
  66   2          case 6:
  67   2            if(System_Flag == 0)
  68   2            {
  69   3              // 每次按键Set_Mod递增: 0->1->2->3(循环到0)
  70   3              if(++Set_Mod == 3)
  71   3              {
  72   4                // 第3次按键:退出设置模式
  73   4                Set_Mod = 0;
  74   4                Setting = 0;
  75   4                Led_Mod = Mod_Set;
  76   4                Led_Data [Led_Mod] = Time[Time_Index];
  77   4              }
  78   3              else if(Set_Mod == 1)
  79   3              {
  80   4                // 第1次按键(Set_Mod=1)
  81   4                Setting = 1;
  82   4                Mod_Set = Led_Mod;
  83   4              }
  84   3              else if(Set_Mod == 2)//第2次按键(Set_Mod=2)
  85   3              {
  86   4                Setting = 1;
  87   4                Led_Set_Data [Mod_Set] = Led_Data [Mod_Set];
  88   4              }
  89   3            }
  90   2          break;
  91   2          case 5:
  92   2            if(Setting == 1) 
  93   2            {
  94   3              if(Set_Mod == 1) 
  95   3              {
  96   4                if(++Mod_Set == 4) Mod_Set = 0;
  97   4              }else if(Set_Mod == 2)
  98   3              {
  99   4                if(++Time_Index == 9) Time_Index = 0;
 100   4                Led_Set_Data [Mod_Set] = Time[Time_Index];
 101   4              }
 102   3            }
 103   2          break;
 104   2          case 4:
 105   2            if(Setting == 1) 
 106   2            {
 107   3              if(Set_Mod == 1) 
 108   3              {
 109   4                if(--Mod_Set == 255) Mod_Set = 3;
 110   4              }else if(Set_Mod == 2)
 111   3              {
 112   4                if(--Time_Index == 255) Time_Index = 8;
 113   4                Led_Set_Data [Mod_Set] = Time[Time_Index];
 114   4              }
 115   3            }
C51 COMPILER V9.59.0.0   MAIN                                                              01/24/2026 21:19:36 PAGE 3   

 116   2          break;
 117   2        }
 118   1      }
 119          /* 信息处理函数 */
 120          void Seg_Proc()
 121          {
 122   1        if (Seg_Slow_Down) return;
 123   1        Seg_Slow_Down =1 ;
 124   1        // 正常显示模式
 125   1        if(Setting == 0)
 126   1        {
 127   2      
 128   2          Seg_Buf[0] = State[System_Flag];
 129   2          Seg_Buf[1] = Led_Mod +1;
 130   2          if((Led_Data[Led_Mod]/1000) == 0)
 131   2          {
 132   3            Seg_Buf[2] = 10;
 133   3          }else
 134   2          {
 135   3            Seg_Buf[2] = Led_Data[Led_Mod]/1000;
 136   3          }
 137   2          Seg_Buf[3] = Led_Data[Led_Mod]/100 %10;
 138   2          Seg_Buf[4] = Led_Data[Led_Mod]%100 /10;
 139   2          Seg_Buf[5] = Led_Data[Led_Mod] %10;
 140   2        }else  // 设置模式(带闪烁)
 141   1        {
 142   2          // 始终先设置显示内容
 143   2          Seg_Buf[0] = State[2];  // 显示"-"符号
 144   2          Seg_Buf[1] = Mod_Set + 1;
 145   2          if((Led_Set_Data[Mod_Set]/1000) == 0)
 146   2          {
 147   3            Seg_Buf[2] = 10;
 148   3          }else
 149   2          {
 150   3            Seg_Buf[2] = Led_Set_Data[Mod_Set]/1000;
 151   3          }
 152   2          Seg_Buf[3] = Led_Set_Data[Mod_Set]/100 %10;
 153   2          Seg_Buf[4] = Led_Set_Data[Mod_Set]%100 /10;
 154   2          Seg_Buf[5] = Led_Set_Data[Mod_Set]%10;
 155   2      
 156   2          // 根据闪烁标志清除对应位置(实现闪烁效果)
 157   2          if(Setting_Flag == 1)
 158   2          {
 159   3            if(Set_Mod == 1)  // 第1次按键6:前两位闪烁
 160   3            {
 161   4              Seg_Buf[0] = 10;
 162   4              Seg_Buf[1] = 10;
 163   4            }
 164   3            else if(Set_Mod == 2)  // 第2次按键6:后三位闪烁
 165   3            {
 166   4              Seg_Buf[2] = 10;
 167   4              Seg_Buf[3] = 10;
 168   4              Seg_Buf[4] = 10;
 169   4              Seg_Buf[5] = 10;
 170   4            }
 171   3          }
 172   2      
 173   2        }
 174   1        //数据显示界面
 175   1        if(DA_Disp == 1)
 176   1        {
 177   2          switch(Led_Mod)
C51 COMPILER V9.59.0.0   MAIN                                                              01/24/2026 21:19:36 PAGE 4   

 178   2          {
 179   3            case 0:
 180   3              Led_Sum2 = Led_Num;
 181   3              Led_Sum1 = 0;
 182   3            break;
 183   3            case 1:
 184   3              Led_Sum2 = Led_Num1;
 185   3              Led_Sum1 = 0;
 186   3            break;
 187   3            case 2:
 188   3              Led_Sum2 = Led_Num2;
 189   3              Led_Sum1 = Led_Num2s;
 190   3            break;
 191   3            case 3:
 192   3              Led_Sum2 = Led_Num3;
 193   3              Led_Sum1 = Led_Num3s;
 194   3            break;
 195   3          }
 196   2          Seg_Buf[0] = 0;
 197   2          Seg_Point[0] = 1;
 198   2          Seg_Buf[1] = 12;
 199   2          Seg_Point[1] = 1;
 200   2          Seg_Buf[2] = State[2];  // 显示"-"符号
 201   2          Seg_Buf[3] = Mod_Set + 1;
 202   2          Seg_Buf[4] = Led_Sum1 ;
 203   2          Seg_Buf[5] = Led_Sum2 ;
 204   2        }
 205   1      }
 206          /* 其他显示函数 */
 207          void Led_Proc()
 208          {
 209   1        if(System_Tick == Led_Data[Led_Mod])
 210   1        {
 211   2          System_Tick = 0;
 212   2          switch(Led_Mod)
 213   2          {
 214   3            case 0:
 215   3            if(Led_Num == 8) Led_Num = 0;
 216   3            Led_Disp(Led_Old,0);
 217   3            Led_Disp(Led_Num,1);
 218   3            Led_Old = Led_Num;
 219   3            Led_Num ++;
 220   3            if(Led_Old == 7) Led_Mod = 1;
 221   3            break;
 222   3            case 1:
 223   3            if(--Led_Num1 == 255) Led_Num1 = 7;
 224   3            Led_Disp(Led_Old1,0);
 225   3            Led_Disp(Led_Num1,1);
 226   3            Led_Old1 = Led_Num1;
 227   3            if(Led_Old1 == 0) Led_Mod = 2;
 228   3            break;
 229   3            case 2:
 230   3            if(Led_Num2 == 4) Led_Num2 = 0;
 231   3            Led_Num2s = 7 - Led_Num2;
 232   3            Led_Disp(Led_Old2s,0);
 233   3            Led_Disp(Led_Old2,0);
 234   3            Led_Disp(Led_Num2s,1);
 235   3            Led_Disp(Led_Num2,1);
 236   3            Led_Old2 = Led_Num2;
 237   3            Led_Old2s = Led_Num2s;
 238   3            Led_Num2 ++;
 239   3            if(Led_Old2 == 3) Led_Mod = 3;
C51 COMPILER V9.59.0.0   MAIN                                                              01/24/2026 21:19:36 PAGE 5   

 240   3            break;
 241   3            case 3:
 242   3            if(--Led_Num3 == 255) Led_Num3 = 3;
 243   3            Led_Num3s = 7 - Led_Num3;
 244   3            Led_Disp(Led_Old3s,0);
 245   3            Led_Disp(Led_Old3,0);
 246   3            Led_Disp(Led_Num3s,1);
 247   3            Led_Disp(Led_Num3,1);
 248   3            Led_Old3 = Led_Num3;
 249   3            Led_Old3s = Led_Num3s;
 250   3            if(Led_Old3 == 0) Led_Mod = 0;
 251   3            break;
 252   3          }
 253   2        }
 254   1      }
 255          /* 定时器0中断初始化函数 */
 256          void Timer0Init(void)   //1毫秒@12.000MHz
 257          {
 258   1        TMOD &= 0xF0;   //设置定时器模式
 259   1        TMOD |= 0x01;   //设置定时器模式
 260   1        TL0 = 0x18;   //设置定时初始值
 261   1        TH0 = 0xFC;   //设置定时初始值
 262   1        TF0 = 0;    //清除TF0标志
 263   1        TR0 = 1;    //定时器0开始计时
 264   1        ET0 = 1;    //定时器0中断打开
 265   1        EA = 1;     //总中断打开
 266   1      }
 267          /* 定时器0中断服务函数 */
 268          void Timer0Server() interrupt 1
 269          {
 270   1        TL0 = 0x18;   //设置定时初始值
 271   1        TH0 = 0xFC;   //设置定时初始值   
 272   1        if(++Key_Slow_Down == 10) Key_Slow_Down = 0;//键盘减速专用
 273   1        if(++Seg_Slow_Down == 50) Seg_Slow_Down = 0;//数码管减速专用
 274   1        if(++Seg_Pos == 6) Seg_Pos = 0;//数码管显示专用
 275   1        Seg_Disp(Seg_Pos, Seg_Buf[Seg_Pos], Seg_Point[Seg_Pos]);
 276   1        if(System_Flag)
 277   1        {
 278   2          System_Tick ++;
 279   2        }
 280   1        if(Setting)  // 设置模式下控制闪烁
 281   1        {
 282   2          // 每400ms翻转一次闪烁标志(显示/隐藏切换)
 283   2          if(++Setting_Tick == 400)
 284   2          {
 285   3            Setting_Tick = 0;
 286   3            Setting_Flag ^= 1;  // 0->1->0->1循环,控制Seg_Proc中的显示/清除
 287   3          }
 288   2        }
 289   1      }
 290          /* Main */
 291          void main()
 292          {
 293   1        Timer0Init();
 294   1        while (1)
 295   1        {
 296   2          Key_Proc();
 297   2          Seg_Proc();
 298   2          Led_Proc();
 299   2        }
 300   1      }

C51 COMPILER V9.59.0.0   MAIN                                                              01/24/2026 21:19:36 PAGE 6   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1149    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     81    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
