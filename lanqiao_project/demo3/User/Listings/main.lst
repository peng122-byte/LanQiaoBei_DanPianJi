C51 COMPILER V9.59.0.0   MAIN                                                              01/24/2026 19:04:09 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keilc51\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* 头文件声明区 */
   2          #include <REGX52.H>//单片机寄存器专用头文件
   3          #include <Key.h>//按键底层驱动专用头文件
   4          #include <Seg.h>//数码管底层驱动专用头文件
   5          #include <intrins.h>
   6          #include <Led.h>
   7          /* 变量声明区 */
   8          unsigned char Key_Val,Key_Down,Key_Old,Key_Up;//按键专用变量
   9          unsigned char Key_Slow_Down;//按键减速专用变量
  10          unsigned char Seg_Buf[6] = {10,10,10,10,10,10};//数码管显示数据存放数组
  11          unsigned char Seg_Point[6] = {0,0,0,0,0,0};//数码管小数点数据存放数组
  12          unsigned char Seg_Pos;//数码管扫描专用变量
  13          unsigned int Seg_Slow_Down;//数码管减速专用变量
  14          unsigned char Led_Mod ;//Led模式 0-模式一：从左到右 1-模式二：从右到左 2-模式三 3-模
             -式四
  15          unsigned char Led_Num,Led_Old;//Led编号
  16          unsigned char Led_Num1,Led_Old1;
  17          unsigned char Led_Num2,Led_Old2,Led_Num2s,Led_Old2s;
  18          unsigned char Led_Num3,Led_Old3,Led_Num3s,Led_Old3s;
  19          unsigned int Time[9] = {400,500,600,700,800,900,1000,1100,1200};//流转时间数组
  20          unsigned char Time_Index;//流转时间数组索引
  21          bit System_Flag ;//系统标志位
  22          unsigned int Led_Set_Data [4] = {400,400,400,400};//各模式流转时间
  23          unsigned int System_Tick;//流转时间计数
  24          unsigned char Set_Mod;//模式变量
  25          bit Setting;//模式标志位
  26          unsigned char State[3] = {11,12,13};//S A -
  27          unsigned char Mod_Set;//模式设置
  28          unsigned char Setting_Tick;
  29          bit Setting_Flag;
  30          
  31          /* 键盘处理函数 */
  32          void Key_Proc()
  33          {
  34   1        if (Key_Slow_Down) return;
  35   1        Key_Slow_Down = 1;//按键减速程序
  36   1        
  37   1        Key_Val = Key_Read();//读取按下的键值
  38   1        Key_Down = Key_Val & (Key_Val ^ Key_Old);//下降沿
  39   1        Key_Up = Key_Old & (Key_Val ^ Key_Old);//上升沿
  40   1        
  41   1        Key_Old = Key_Val;//辅助扫描
  42   1        
  43   1        switch(Key_Down)
  44   1        {
  45   2          case 7:
  46   2            System_Flag ^= 1;
  47   2          break;
  48   2          case 6:
  49   2            if(System_Flag == 0) 
  50   2            {
  51   3              Setting ^= 1;
  52   3              if(++Set_Mod == 3) 
  53   3              {
C51 COMPILER V9.59.0.0   MAIN                                                              01/24/2026 19:04:09 PAGE 2   

  54   4                Set_Mod = 0;
  55   4                Setting ^= 1;
  56   4              }
  57   3            }
  58   2          break;
  59   2          case 5:
  60   2            if(Setting == 1) 
  61   2            {
  62   3              if(Set_Mod == 1) 
  63   3              {
  64   4                
  65   4              }else
  66   3              {
  67   4                
  68   4              }
  69   3            }
  70   2          break;
  71   2          case 4:
  72   2            if(Setting == 1) 
  73   2            {
  74   3              if(Set_Mod == 1) 
  75   3              {
  76   4                
  77   4              }else
  78   3              {
  79   4                
  80   4              }
  81   3            }
  82   2          break;
  83   2            
  84   2        }
  85   1      }
  86          
  87          
  88          
  89          /* 信息处理函数 */
  90          void Seg_Proc()
  91          {
  92   1        if (Seg_Slow_Down) return;
  93   1        Seg_Slow_Down =1 ;
  94   1        if(Setting == 0)
  95   1        {
  96   2          
  97   2          Seg_Buf[0] = State[System_Flag];
  98   2          Seg_Buf[1] = Led_Mod +1;
  99   2          Seg_Buf[3] = Led_Set_Data[Led_Mod]/100;
 100   2          Seg_Buf[4] = Led_Set_Data[Led_Mod]%100 /10;
 101   2          Seg_Buf[5] = Led_Set_Data[Led_Mod]%100 %10;
 102   2        }else
 103   1        {
 104   2          // 始终先设置显示内容
 105   2          Seg_Buf[0] = State[2];
 106   2          Mod_Set = Led_Mod;
 107   2          Seg_Buf[1] = Mod_Set + 1;
 108   2          Seg_Buf[3] = Led_Set_Data[Mod_Set]/100;
 109   2          Seg_Buf[4] = Led_Set_Data[Mod_Set]%100 /10;
 110   2          Seg_Buf[5] = Led_Set_Data[Mod_Set]%100 %10;
 111   2      
 112   2          // 根据闪烁标志清除对应位置
 113   2          if(Setting_Flag == 1)
 114   2          {
 115   3            if(Set_Mod == 1)
C51 COMPILER V9.59.0.0   MAIN                                                              01/24/2026 19:04:09 PAGE 3   

 116   3            {
 117   4              Seg_Buf[0] = 10;
 118   4              Seg_Buf[1] = 10;
 119   4            }
 120   3            else if(Set_Mod == 2)
 121   3            {
 122   4              Seg_Buf[3] = 10;
 123   4              Seg_Buf[4] = 10;
 124   4              Seg_Buf[5] = 10;
 125   4            }
 126   3          }
 127   2      
 128   2        }
 129   1        
 130   1        
 131   1      }
 132          
 133          
 134          
 135          
 136          /* 其他显示函数 */
 137          void Led_Proc()
 138          {
 139   1        if(System_Tick == Led_Set_Data[Led_Mod])
 140   1        {
 141   2          System_Tick = 0;
 142   2          switch(Led_Mod)
 143   2          {
 144   3            case 0:
 145   3            if(Led_Num == 8) Led_Num = 0;
 146   3            Led_Disp(Led_Old,0);
 147   3            Led_Disp(Led_Num,1);
 148   3            Led_Old = Led_Num;
 149   3            Led_Num ++;
 150   3            if(Led_Old == 7) Led_Mod = 1;
 151   3            break;
 152   3            case 1:
 153   3            if(--Led_Num1 == 255) Led_Num1 = 7;
 154   3            Led_Disp(Led_Old1,0);
 155   3            Led_Disp(Led_Num1,1);
 156   3            Led_Old1 = Led_Num1;
 157   3            if(Led_Old1 == 0) Led_Mod = 2;
 158   3      
 159   3            break;
 160   3            case 2:
 161   3            if(Led_Num2 == 4) Led_Num2 = 0;
 162   3            Led_Num2s = 7 - Led_Num2;
 163   3            Led_Disp(Led_Old2s,0);
 164   3            Led_Disp(Led_Old2,0);
 165   3            Led_Disp(Led_Num2s,1);
 166   3            Led_Disp(Led_Num2,1);
 167   3            Led_Old2 = Led_Num2;
 168   3            Led_Old2s = Led_Num2s;
 169   3            Led_Num2 ++;
 170   3            if(Led_Old2 == 3) Led_Mod = 3;
 171   3            break;
 172   3            case 3:
 173   3            if(--Led_Num3 == 255) Led_Num3 = 3;
 174   3            Led_Num3s = 7 - Led_Num3;
 175   3            Led_Disp(Led_Old3s,0);
 176   3            Led_Disp(Led_Old3,0);
 177   3            Led_Disp(Led_Num3s,1);
C51 COMPILER V9.59.0.0   MAIN                                                              01/24/2026 19:04:09 PAGE 4   

 178   3            Led_Disp(Led_Num3,1);
 179   3            Led_Old3 = Led_Num3;
 180   3            Led_Old3s = Led_Num3s;
 181   3            if(Led_Old3 == 0) Led_Mod = 0;
 182   3            break;
 183   3            
 184   3          }
 185   2        }
 186   1      
 187   1        
 188   1      }
 189          
 190          
 191          
 192          
 193          /* 定时器0中断初始化函数 */
 194          void Timer0Init(void)   //1毫秒@12.000MHz
 195          {
 196   1        TMOD &= 0xF0;   //设置定时器模式
 197   1        TMOD |= 0x01;   //设置定时器模式
 198   1        TL0 = 0x18;   //设置定时初始值
 199   1        TH0 = 0xFC;   //设置定时初始值
 200   1        TF0 = 0;    //清除TF0标志
 201   1        TR0 = 1;    //定时器0开始计时
 202   1        ET0 = 1;    //定时器0中断打开
 203   1        EA = 1;     //总中断打开
 204   1      }
 205          
 206          
 207          /* 定时器0中断服务函数 */
 208          void Timer0Server() interrupt 1
 209          {
 210   1        TL0 = 0x18;   //设置定时初始值
 211   1        TH0 = 0xFC;   //设置定时初始值   
 212   1        if(++Key_Slow_Down == 10) Key_Slow_Down = 0;//键盘减速专用
 213   1        if(++Seg_Slow_Down == 50) Seg_Slow_Down = 0;//数码管减速专用
 214   1        if(++Seg_Pos == 6) Seg_Pos = 0;//数码管显示专用
 215   1        Seg_Disp(Seg_Pos, Seg_Buf[Seg_Pos], Seg_Point[Seg_Pos]);
 216   1        if(System_Flag)
 217   1        {
 218   2          System_Tick ++;
 219   2        }
 220   1        if(Setting)
 221   1        {
 222   2          if(++Setting_Tick == 400)
 223   2          {
 224   3            Setting_Tick = 0;
 225   3            Setting_Flag ^= 1;
 226   3          }
 227   2        }
 228   1        
 229   1        
 230   1        
 231   1          
 232   1      
 233   1        
 234   1      }
 235          
 236          /* Main */
 237          void main()
 238          {
 239   1        Timer0Init();
C51 COMPILER V9.59.0.0   MAIN                                                              01/24/2026 19:04:09 PAGE 5   

 240   1        while (1)
 241   1        {
 242   2          Key_Proc();
 243   2          Seg_Proc();
 244   2          Led_Proc();
 245   2        }
 246   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    737    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     68    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
