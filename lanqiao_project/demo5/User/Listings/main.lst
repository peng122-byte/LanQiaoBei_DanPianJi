C51 COMPILER V9.59.0.0   MAIN                                                              01/30/2026 23:54:54 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keilc51\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* Â§¥Êñá‰ª∂Â£∞ÊòéÂå∫ */
   2          #include <REGX52.H>//ÂçïÁâáÊú∫ÂØÑÂ≠òÂô®‰∏ìÁî®Â§¥Êñá‰ª∂
   3          #include <Key.h>//ÊåâÈîÆÂ∫ïÂ±ÇÈ©±Âä®‰∏ìÁî®Â§¥Êñá‰ª∂
   4          #include <Seg.h>//Êï∞Á†ÅÁÆ°Â∫ïÂ±ÇÈ©±Âä®‰∏ìÁî®Â§¥Êñá‰ª∂
   5          #include <intrins.h>
   6          #include <Led.h>
   7          /* ÂèòÈáèÂ£∞ÊòéÂå∫ */
   8          unsigned char Key_Val,Key_Down,Key_Old,Key_Up;//ÊåâÈîÆ‰∏ìÁî®ÂèòÈáè
   9          unsigned char Key_Slow_Down;//ÊåâÈîÆÂáèÈÄü‰∏ìÁî®ÂèòÈáè
  10          unsigned char Seg_Buf[6] = {10,10,10,10,10,10};//Êï∞Á†ÅÁÆ°ÊòæÁ§∫Êï∞ÊçÆÂ≠òÊîæÊï∞ÁªÑ
  11          unsigned char Seg_Point[6] = {0,0,0,0,0,0};//Êï∞Á†ÅÁÆ°Â∞èÊï∞ÁÇπÊï∞ÊçÆÂ≠òÊîæÊï∞ÁªÑ
  12          unsigned char Seg_Pos;//Êï∞Á†ÅÁÆ°Êâ´Êèè‰∏ìÁî®ÂèòÈáè
  13          unsigned int  Seg_Slow_Down;//Êï∞Á†ÅÁÆ°ÂáèÈÄü‰∏ìÁî®ÂèòÈáè
  14          unsigned char ucLed[8] = {0,0,0,0,0,0,0,0};//LedÊòæÁ§∫Êï∞ÁªÑ
  15          unsigned char Led_Pos;//LedÊâ´Êèè‰∏ìÁî®ÂèòÈáè
  16          unsigned char Seg_Dis_Mode;//Êï∞Á†ÅÁÆ°ÊòæÁ§∫Ê®°Âºè 0-Ê∏©Â∫¶ÈááÈõÜÁïåÈù¢ 1-Êï∞ÊçÆÊòæÁ§∫ÁïåÈù¢ 2-ÂèÇÊï∞ËÆæÁΩ
             -ÆÁïåÈù¢
  17          unsigned char Temperature_Input[3] = {13,13,13};//Ê∏©Â∫¶ËæìÂÖ•Êï∞ÁªÑ
  18          unsigned char Temperature_Input_Point[3] = {0,0,0};//Â∞èÊï∞ÁÇπËæìÂÖ•Êï∞ÁªÑ
  19          bit Num_Input;//Êï∞Â≠óËæìÂÖ•ÂÆåÊàêÊ†áÂøó‰Ωç
  20          bit Point_Input;//Â∞èÊï∞ÁÇπËæìÂÖ•ÂÆåÊàêÊ†áÂøó‰Ωç
  21          unsigned int  Temperature_Input_Data;//Ê∏©Â∫¶ËæìÂÖ•Êï∞ÊçÆ
  22          unsigned char Temperature_Input_Index ;//Ê∏©Â∫¶ËæìÂÖ•Êï∞ÁªÑÁ¥¢Âºï
  23          unsigned int  Time250; 
  24          bit Flag_0;//Ê®°Âºè0Èó™ÁÉÅÊ†áÂøó‰Ωç
  25          unsigned char Temperature_Real [3] ={0,0,0};//ÂÆûÈôÖÊ∏©Â∫¶Êï∞ÊçÆ
  26          unsigned char TMAX;//Ê∏©Â∫¶‰∏äÈôêÂèÇÊï∞
  27          unsigned char TMIN;//Ê∏©Â∫¶‰∏ãÈôêÂèÇÊï∞
  28          unsigned char Temperature_Setting[4]  ={3,0,2,0};//Ê∏©Â∫¶ÂèÇÊï∞ËÆæÁΩÆÊï∞ÁªÑ
  29          unsigned char Temperature_Setting_Index;//Ê∏©Â∫¶ÂèÇÊï∞ËÆæÁΩÆÊï∞ÁªÑÁ¥¢Âºï
  30          bit Flag_2;//Ê®°Âºè2Èó™ÁÉÅÊ†áÂøó‰Ωç
  31          unsigned char Point_Wei;//Â∞èÊï∞ÁÇπÊâÄÂú®‰ΩçÊï∞
  32          bit Mode_Switch;//Ê®°ÂºèÂàáÊç¢Ê†áÂøó‰Ωç
  33          /* ÈîÆÁõòÂ§ÑÁêÜÂáΩÊï∞ */
  34          void Key_Proc()
  35          {
  36   1        unsigned char i;
  37   1        unsigned char j;
  38   1        if (Key_Slow_Down) return;
  39   1        Key_Slow_Down = 1;//ÊåâÈîÆÂáèÈÄüÁ®ãÂ∫è
  40   1        
  41   1        Key_Val = Key_Read();//ËØªÂèñÊåâ‰∏ãÁöÑÈîÆÂÄº
  42   1        Key_Down = Key_Val & (Key_Val ^ Key_Old);//‰∏ãÈôçÊ≤ø
  43   1        Key_Up = Key_Old & (Key_Val ^ Key_Old);//‰∏äÂçáÊ≤ø
  44   1        
  45   1        Key_Old = Key_Val;//ËæÖÂä©Êâ´Êèè
  46   1        
  47   1        if(Seg_Dis_Mode == 0)
  48   1        {
  49   2          
  50   2          if((Key_Down > 0) && (Key_Down <= 10) )
  51   2          {
  52   3            if(Temperature_Input_Index < 3)
  53   3            {
C51 COMPILER V9.59.0.0   MAIN                                                              01/30/2026 23:54:54 PAGE 2   

  54   4              Temperature_Input[Temperature_Input_Index] = Key_Down - 1;
  55   4              Num_Input = 1;
  56   4              Temperature_Input_Index ++;
  57   4            }
  58   3          }
  59   2          if((Key_Down == 11) &&  (Num_Input == 1) && (Point_Input == 0))
  60   2          {
  61   3            if(Temperature_Input_Index > 0)
  62   3            {
  63   4              Num_Input = 0;
  64   4              Point_Input = 1;
  65   4              Temperature_Input_Point[Temperature_Input_Index - 1] = 1;
  66   4      
  67   4            }
  68   3          }
  69   2        }
  70   1        if(Key_Down == 16)
  71   1        {
  72   2          if(Seg_Dis_Mode == 0)
  73   2          {
  74   3            for(i=0;i<3;i ++)
  75   3            {
  76   4              if(Temperature_Input_Point[i] == 1) Point_Wei = i;
  77   4              if(Point_Input == 0) Point_Wei = 2;
  78   4              
  79   4            }
  80   3            switch(Point_Wei)
  81   3            {
  82   4              case 0:
  83   4                Temperature_Real [1] = 0;
  84   4                Temperature_Real [2] = Temperature_Input [0];
  85   4                if(Temperature_Input [1] >= 5)
  86   4                {
  87   5                  Temperature_Real [2] ++;
  88   5                  if(Temperature_Real [2] == 10)
  89   5                  {
  90   6                    Temperature_Real [2] = 0;
  91   6                    Temperature_Real [1] ++;
  92   6                  }
  93   5                }
  94   4              break;
  95   4              case 1:
  96   4                Temperature_Real [1] = Temperature_Input [0];
  97   4                Temperature_Real [2] = Temperature_Input [1];
  98   4                if(Temperature_Input [2] >= 5)
  99   4                  {
 100   5                    Temperature_Real [2] ++;
 101   5                    if(Temperature_Real [2] == 10)
 102   5                    {
 103   6                      Temperature_Real [2] = 0;
 104   6                      Temperature_Real [1] ++;
 105   6                      if(Temperature_Real [1] == 10)
 106   6                      {
 107   7                        Temperature_Real [1] = 0;
 108   7                        Temperature_Real [0] ++;
 109   7                      }
 110   6                    }
 111   5                  }
 112   4              break;
 113   4              case 2:
 114   4                Temperature_Input_Index = 0;  //ÈáçÁΩÆÔºÅ
 115   4                Num_Input = 0;
C51 COMPILER V9.59.0.0   MAIN                                                              01/30/2026 23:54:54 PAGE 3   

 116   4                Point_Input = 0;
 117   4                for(j=0;j<3;j++)
 118   4                {
 119   5                  Temperature_Real [j] = 0;
 120   5                }
 121   4                for(i=0;i<3;i++)
 122   4                {
 123   5                  Temperature_Input_Point[i] = 0;
 124   5                  Temperature_Input[i] = 13;
 125   5                }
 126   4              break;
 127   4            }
 128   3            Temperature_Input_Data = Temperature_Real [0]*100 + Temperature_Real [1]*10 + Temperature_Real [2];
 129   3            if((Temperature_Input_Data >= 0) && (Temperature_Input_Data <= 85) && (Num_Input == 1))
 130   3            {
 131   4              Seg_Dis_Mode = 1;
 132   4            }else
 133   3            {
 134   4              Temperature_Input_Index = 0;  //ÈáçÁΩÆÔºÅ
 135   4              Num_Input = 0;
 136   4              Point_Input = 0;
 137   4              for(j=0;j<3;j++)
 138   4              {
 139   5                Temperature_Real [j] = 0;
 140   5              }
 141   4              for(i=0;i<3;i++)
 142   4              {
 143   5                Temperature_Input_Point[i] = 0;
 144   5                Temperature_Input[i] = 13;
 145   5              }
 146   4            }
 147   3      
 148   3          }else
 149   2          {
 150   3            Seg_Dis_Mode = 0;
 151   3          }
 152   2        }
 153   1        if(Key_Down == 12)
 154   1        {
 155   2          if(Seg_Dis_Mode == 1)
 156   2          {
 157   3            Seg_Dis_Mode = 2;
 158   3          }else if(Seg_Dis_Mode == 2)
 159   2          {
 160   3            Seg_Dis_Mode = 1;
 161   3          }
 162   2        }
 163   1        if(Key_Down == 13)
 164   1        {
 165   2          Temperature_Setting_Index += 2;
 166   2          if(++Temperature_Setting_Index == 4) Temperature_Setting_Index = 0;
 167   2        }
 168   1      }
 169          
 170          
 171          
 172          /* ‰ø°ÊÅØÂ§ÑÁêÜÂáΩÊï∞ */
 173          void Seg_Proc()
 174          {
 175   1        if (Seg_Slow_Down) return;
 176   1        Seg_Slow_Down =1 ;
 177   1        switch (Seg_Dis_Mode)
C51 COMPILER V9.59.0.0   MAIN                                                              01/30/2026 23:54:54 PAGE 4   

 178   1        {
 179   2          case 0:
 180   2            Seg_Buf[0] = 12;
 181   2            Seg_Buf[1] = 10;
 182   2            Seg_Buf[2] = 10;
 183   2            Seg_Buf[3] = Temperature_Input[0];
 184   2            Seg_Point[3] = Temperature_Input_Point[0];
 185   2            Seg_Buf[4] = Temperature_Input[1];
 186   2            Seg_Point[4] = Temperature_Input_Point[1];
 187   2            Seg_Buf[5] = Temperature_Input[2];
 188   2            
 189   2            if(Flag_0)
 190   2            {
 191   3              if(Temperature_Input_Index < 2)
 192   3              {
 193   4                Seg_Buf[Temperature_Input_Index + 3] = 10;
 194   4              }
 195   3              if(Temperature_Input_Index == 2)  Seg_Buf[5] = 10;
 196   3            }
 197   2          break;
 198   2          case 1:
 199   2            Seg_Buf[0] = 14;
 200   2            Seg_Buf[1] = 10;
 201   2            Seg_Buf[2] = 10;
 202   2            Seg_Buf[3] = 10;
 203   2            Seg_Point[3] = 0;
 204   2            Seg_Point[4] = 0;
 205   2            Seg_Buf[4] = Temperature_Real [1] ;
 206   2            Seg_Buf[5] = Temperature_Real [2] ;
 207   2          break;
 208   2          case 2:
 209   2            Seg_Buf[0] = 15;
 210   2            Seg_Buf[1] = 10;
 211   2            Seg_Buf[2] = Temperature_Setting[0] ;
 212   2            Seg_Buf[3] = Temperature_Setting[1] ;
 213   2            Seg_Buf[4] = Temperature_Setting[2] ;
 214   2            Seg_Buf[5] = Temperature_Setting[3] ;
 215   2          if(Flag_2)
 216   2            {
 217   3              Seg_Buf[Temperature_Setting_Index + 2] = 10;
 218   3              Seg_Buf[Temperature_Setting_Index + 3] = 10;
 219   3            }
 220   2          break;
 221   2        }
 222   1      }
 223          /* ÂÖ∂‰ªñÊòæÁ§∫ÂáΩÊï∞ */
 224          void Led_Proc()
 225          {
 226   1        
 227   1      }
 228          
 229          
 230          
 231          
 232          /* ÂÆöÊó∂Âô®0‰∏≠Êñ≠ÂàùÂßãÂåñÂáΩÊï∞ */
 233          void Timer0Init(void)   //1ÊØ´Áßí@12.000MHz
 234          {
 235   1        TMOD &= 0xF0;   //ËÆæÁΩÆÂÆöÊó∂Âô®Ê®°Âºè
 236   1        TMOD |= 0x01;   //ËÆæÁΩÆÂÆöÊó∂Âô®Ê®°Âºè
 237   1        TL0 = 0x18;   //ËÆæÁΩÆÂÆöÊó∂ÂàùÂßãÂÄº
 238   1        TH0 = 0xFC;   //ËÆæÁΩÆÂÆöÊó∂ÂàùÂßãÂÄº
 239   1        TF0 = 0;    //Ê∏ÖÈô§TF0Ê†áÂøó
C51 COMPILER V9.59.0.0   MAIN                                                              01/30/2026 23:54:54 PAGE 5   

 240   1        TR0 = 1;    //ÂÆöÊó∂Âô®0ÂºÄÂßãËÆ°Êó∂
 241   1        ET0 = 1;    //ÂÆöÊó∂Âô®0‰∏≠Êñ≠ÊâìÂºÄ
 242   1        EA = 1;     //ÊÄª‰∏≠Êñ≠ÊâìÂºÄ
 243   1      }
 244          
 245          
 246          /* ÂÆöÊó∂Âô®0‰∏≠Êñ≠ÊúçÂä°ÂáΩÊï∞ */
 247          void Timer0Server() interrupt 1
 248          {
 249   1        TL0 = 0x18;   //ËÆæÁΩÆÂÆöÊó∂ÂàùÂßãÂÄº
 250   1        TH0 = 0xFC;   //ËÆæÁΩÆÂÆöÊó∂ÂàùÂßãÂÄº   
 251   1        if(++Key_Slow_Down == 10) Key_Slow_Down = 0;//ÈîÆÁõòÂáèÈÄü‰∏ìÁî®
 252   1        if(++Seg_Slow_Down == 50) Seg_Slow_Down = 0;//Êï∞Á†ÅÁÆ°ÂáèÈÄü‰∏ìÁî®
 253   1        if(++Seg_Pos == 6) Seg_Pos = 0;//Êï∞Á†ÅÁÆ°ÊòæÁ§∫‰∏ìÁî®
 254   1        if(++Led_Pos == 8) Led_Pos = 0;//LedÊòæÁ§∫‰∏ìÁî®
 255   1        Led_Disp(Led_Pos,ucLed[Led_Pos]);
 256   1        Seg_Disp(Seg_Pos, Seg_Buf[Seg_Pos], Seg_Point[Seg_Pos]);
 257   1        if(++Time250 ==250)
 258   1        {
 259   2          Time250 = 0;
 260   2          if(Seg_Dis_Mode == 0) Flag_0 ^= 1;
 261   2          if(Seg_Dis_Mode == 2) Flag_2 ^= 1;
 262   2        }
 263   1        
 264   1        
 265   1        
 266   1          
 267   1      
 268   1        
 269   1      }
 270          
 271          /* Main */
 272          void main()
 273          {
 274   1        Timer0Init();
 275   1        while (1)
 276   1        {
 277   2          Key_Proc();
 278   2          Seg_Proc();
 279   2          Led_Proc();
 280   2        }
 281   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    849    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     52       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
