C51 COMPILER V9.59.0.0   MAIN                                                              01/30/2026 23:49:01 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keilc51\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* Â§¥Êñá‰ª∂Â£∞ÊòéÂå∫ */
   2          #include <REGX52.H>//ÂçïÁâáÊú∫ÂØÑÂ≠òÂô®‰∏ìÁî®Â§¥Êñá‰ª∂
   3          #include <Key.h>//ÊåâÈîÆÂ∫ïÂ±ÇÈ©±Âä®‰∏ìÁî®Â§¥Êñá‰ª∂
   4          #include <Seg.h>//Êï∞Á†ÅÁÆ°Â∫ïÂ±ÇÈ©±Âä®‰∏ìÁî®Â§¥Êñá‰ª∂
   5          #include <intrins.h>
   6          #include <Led.h>
   7          /* ÂèòÈáèÂ£∞ÊòéÂå∫ */
   8          unsigned char Key_Val,Key_Down,Key_Old,Key_Up;//ÊåâÈîÆ‰∏ìÁî®ÂèòÈáè
   9          unsigned char Key_Slow_Down;//ÊåâÈîÆÂáèÈÄü‰∏ìÁî®ÂèòÈáè
  10          unsigned char Seg_Buf[6] = {10,10,10,10,10,10};//Êï∞Á†ÅÁÆ°ÊòæÁ§∫Êï∞ÊçÆÂ≠òÊîæÊï∞ÁªÑ
  11          unsigned char Seg_Point[6] = {0,0,0,0,0,0};//Êï∞Á†ÅÁÆ°Â∞èÊï∞ÁÇπÊï∞ÊçÆÂ≠òÊîæÊï∞ÁªÑ
  12          unsigned char Seg_Pos;//Êï∞Á†ÅÁÆ°Êâ´Êèè‰∏ìÁî®ÂèòÈáè
  13          unsigned int  Seg_Slow_Down;//Êï∞Á†ÅÁÆ°ÂáèÈÄü‰∏ìÁî®ÂèòÈáè
  14          unsigned char ucLed[8] = {0,0,0,0,0,0,0,0};//LedÊòæÁ§∫Êï∞ÁªÑ
  15          unsigned char Led_Pos;//LedÊâ´Êèè‰∏ìÁî®ÂèòÈáè
  16          unsigned char Seg_Dis_Mode;//Êï∞Á†ÅÁÆ°ÊòæÁ§∫Ê®°Âºè 0-Ê∏©Â∫¶ÈááÈõÜÁïåÈù¢ 1-Êï∞ÊçÆÊòæÁ§∫ÁïåÈù¢ 2-ÂèÇÊï∞ËÆæÁΩ
             -ÆÁïåÈù¢
  17          unsigned char Temperature_Input[3] = {13,13,13};//Ê∏©Â∫¶ËæìÂÖ•Êï∞ÁªÑ
  18          unsigned char Temperature_Input_Point[3] = {0,0,0};//Â∞èÊï∞ÁÇπËæìÂÖ•Êï∞ÁªÑ
  19          bit Num_Input;//Êï∞Â≠óËæìÂÖ•ÂÆåÊàêÊ†áÂøó‰Ωç
  20          bit Point_Input;//Â∞èÊï∞ÁÇπËæìÂÖ•ÂÆåÊàêÊ†áÂøó‰Ωç
  21          unsigned int  Temperature_Input_Data;//Ê∏©Â∫¶ËæìÂÖ•Êï∞ÊçÆ
  22          unsigned char Temperature_Input_Index ;//Ê∏©Â∫¶ËæìÂÖ•Êï∞ÁªÑÁ¥¢Âºï
  23          unsigned int  Time250; 
  24          bit Flag_0;//Ê®°Âºè0Èó™ÁÉÅÊ†áÂøó‰Ωç
  25          unsigned char Temperature_Real [3] ={0,0,0};//ÂÆûÈôÖÊ∏©Â∫¶Êï∞ÊçÆ
  26          unsigned char TMAX;//Ê∏©Â∫¶‰∏äÈôêÂèÇÊï∞
  27          unsigned char TMIN;//Ê∏©Â∫¶‰∏ãÈôêÂèÇÊï∞
  28          unsigned char Temperature_Setting[4]  ={3,0,2,0};//Ê∏©Â∫¶ÂèÇÊï∞ËÆæÁΩÆÊï∞ÁªÑ
  29          unsigned char Temperature_Setting_Index;//Ê∏©Â∫¶ÂèÇÊï∞ËÆæÁΩÆÊï∞ÁªÑÁ¥¢Âºï
  30          bit Flag_2;//Ê®°Âºè2Èó™ÁÉÅÊ†áÂøó‰Ωç
  31          unsigned char Point_Wei;//Â∞èÊï∞ÁÇπÊâÄÂú®‰ΩçÊï∞
  32          bit Mode_Switch;//Ê®°ÂºèÂàáÊç¢Ê†áÂøó‰Ωç
  33          /* ÈîÆÁõòÂ§ÑÁêÜÂáΩÊï∞ */
  34          void Key_Proc()
  35          {
  36   1        unsigned char i;
  37   1        unsigned char j;
  38   1        if (Key_Slow_Down) return;
  39   1        Key_Slow_Down = 1;//ÊåâÈîÆÂáèÈÄüÁ®ãÂ∫è
  40   1        
  41   1        Key_Val = Key_Read();//ËØªÂèñÊåâ‰∏ãÁöÑÈîÆÂÄº
  42   1        Key_Down = Key_Val & (Key_Val ^ Key_Old);//‰∏ãÈôçÊ≤ø
  43   1        Key_Up = Key_Old & (Key_Val ^ Key_Old);//‰∏äÂçáÊ≤ø
  44   1        
  45   1        Key_Old = Key_Val;//ËæÖÂä©Êâ´Êèè
  46   1        
  47   1        if(Seg_Dis_Mode == 0)
  48   1        {
  49   2          
  50   2          if((Key_Down > 0) && (Key_Down <= 10) )
  51   2          {
  52   3            if(Temperature_Input_Index < 3)
  53   3            {
C51 COMPILER V9.59.0.0   MAIN                                                              01/30/2026 23:49:01 PAGE 2   

  54   4              Temperature_Input[Temperature_Input_Index] = Key_Down - 1;
  55   4              Num_Input = 1;
  56   4              Temperature_Input_Index ++;
  57   4            }
  58   3          }
  59   2          if((Key_Down == 11) &&  (Num_Input == 1) && (Point_Input == 0))
  60   2          {
  61   3            if(Temperature_Input_Index > 0)
  62   3            {
  63   4              Num_Input = 0;
  64   4              Point_Input = 1;
  65   4              Temperature_Input_Point[Temperature_Input_Index - 1] = 1;
  66   4      
  67   4            }
  68   3          }
  69   2        }
  70   1        if(Key_Down == 16)
  71   1        {
  72   2          if(Seg_Dis_Mode == 0)
  73   2          {
  74   3            for(i=0;i<3;i ++)
  75   3            {
  76   4              if(Temperature_Input_Point[i] == 1) Point_Wei = i;
  77   4              if(Point_Input == 0) Point_Wei = 2;
  78   4              
  79   4            }
  80   3            switch(Point_Wei)
  81   3            {
  82   4              case 0:
  83   4                Temperature_Real [1] = 0;
  84   4                Temperature_Real [2] = Temperature_Input [0];
  85   4                if(Temperature_Input [1] >= 5)
  86   4                {
  87   5                  Temperature_Real [2] ++;
  88   5                  if(Temperature_Real [2] == 10)
  89   5                  {
  90   6                    Temperature_Real [2] = 0;
  91   6                    Temperature_Real [1] ++;
  92   6                  }
  93   5                }
  94   4              break;
  95   4              case 1:
  96   4                Temperature_Real [1] = Temperature_Input [0];
  97   4                Temperature_Real [2] = Temperature_Input [1];
  98   4                if(Temperature_Input [2] >= 5)
  99   4                  {
 100   5                    Temperature_Real [2] ++;
 101   5                    if(Temperature_Real [2] == 10)
 102   5                    {
 103   6                      Temperature_Real [2] = 0;
 104   6                      Temperature_Real [1] ++;
 105   6                      if(Temperature_Real [1] == 10)
 106   6                      {
 107   7                        Temperature_Real [1] = 0;
 108   7                        Temperature_Real [0] ++;
 109   7                      }
 110   6                    }
 111   5                  }
 112   4              break;
 113   4              case 2:
 114   4                Temperature_Input_Index = 0;  //ÈáçÁΩÆÔºÅ
 115   4                Num_Input = 0;
C51 COMPILER V9.59.0.0   MAIN                                                              01/30/2026 23:49:01 PAGE 3   

 116   4                Point_Input = 0;
 117   4                for(j=0;j<3;j++)
 118   4                {
 119   5                  Temperature_Real [j] = 0;
 120   5                }
 121   4                for(i=0;i<3;i++)
 122   4                {
 123   5                  Temperature_Input_Point[i] = 0;
 124   5                  Temperature_Input[i] = 13;
 125   5                }
 126   4              break;
 127   4            }
 128   3            Temperature_Input_Data = Temperature_Real [0]*100 + Temperature_Real [1]*10 + Temperature_Real [2];
 129   3            if((Temperature_Input_Data >= 0) && (Temperature_Input_Data <= 85) && (Num_Input == 1))
 130   3            {
 131   4              Seg_Dis_Mode = 1;
 132   4            }else
 133   3            {
 134   4              Temperature_Input_Index = 0;  //ÈáçÁΩÆÔºÅ
 135   4              Num_Input = 0;
 136   4              Point_Input = 0;
 137   4              for(j=0;j<3;j++)
 138   4              {
 139   5                Temperature_Real [j] = 0;
 140   5              }
 141   4              for(i=0;i<3;i++)
 142   4              {
 143   5                Temperature_Input_Point[i] = 0;
 144   5                Temperature_Input[i] = 13;
 145   5              }
 146   4            }
 147   3      
 148   3          }else
 149   2          {
 150   3            Seg_Dis_Mode = 0;
 151   3          }
 152   2        }
 153   1        if(Key_Down == 12)
 154   1        {
 155   2          if(Seg_Dis_Mode == 1)
 156   2          {
 157   3            Seg_Dis_Mode = 2;
 158   3          }else if(Seg_Dis_Mode == 2)
 159   2          {
 160   3            Seg_Dis_Mode = 1;
 161   3          }
 162   2        }
 163   1      }
 164          
 165          
 166          
 167          /* ‰ø°ÊÅØÂ§ÑÁêÜÂáΩÊï∞ */
 168          void Seg_Proc()
 169          {
 170   1        if (Seg_Slow_Down) return;
 171   1        Seg_Slow_Down =1 ;
 172   1        switch (Seg_Dis_Mode)
 173   1        {
 174   2          case 0:
 175   2            Seg_Buf[0] = 12;
 176   2            Seg_Buf[1] = 10;
 177   2            Seg_Buf[2] = 10;
C51 COMPILER V9.59.0.0   MAIN                                                              01/30/2026 23:49:01 PAGE 4   

 178   2            Seg_Buf[3] = Temperature_Input[0];
 179   2            Seg_Point[3] = Temperature_Input_Point[0];
 180   2            Seg_Buf[4] = Temperature_Input[1];
 181   2            Seg_Point[4] = Temperature_Input_Point[1];
 182   2            Seg_Buf[5] = Temperature_Input[2];
 183   2            
 184   2            if(Flag_0)
 185   2            {
 186   3              if(Temperature_Input_Index < 2)
 187   3              {
 188   4                Seg_Buf[Temperature_Input_Index + 3] = 10;
 189   4              }
 190   3              if(Temperature_Input_Index == 2)  Seg_Buf[5] = 10;
 191   3            }
 192   2          break;
 193   2          case 1:
 194   2            Seg_Buf[0] = 14;
 195   2            Seg_Buf[1] = 10;
 196   2            Seg_Buf[2] = 10;
 197   2            Seg_Buf[3] = 10;
 198   2            Seg_Point[3] = 0;
 199   2            Seg_Point[4] = 0;
 200   2            Seg_Buf[4] = Temperature_Real [1] ;
 201   2            Seg_Buf[5] = Temperature_Real [2] ;
 202   2          break;
 203   2          case 2:
 204   2            Seg_Buf[0] = 15;
 205   2            Seg_Buf[1] = 10;
 206   2            Seg_Buf[2] = Temperature_Setting[0] ;
 207   2            Seg_Buf[3] = Temperature_Setting[1] ;
 208   2            Seg_Buf[4] = Temperature_Setting[2] ;
 209   2            Seg_Buf[5] = Temperature_Setting[3] ;
 210   2          if(Flag_2)
 211   2            {
 212   3              Seg_Buf[Temperature_Setting_Index + 2] = 10;
 213   3              Seg_Buf[Temperature_Setting_Index + 3] = 10;
 214   3            }
 215   2          break;
 216   2        }
 217   1      }
 218          /* ÂÖ∂‰ªñÊòæÁ§∫ÂáΩÊï∞ */
 219          void Led_Proc()
 220          {
 221   1        
 222   1      }
 223          
 224          
 225          
 226          
 227          /* ÂÆöÊó∂Âô®0‰∏≠Êñ≠ÂàùÂßãÂåñÂáΩÊï∞ */
 228          void Timer0Init(void)   //1ÊØ´Áßí@12.000MHz
 229          {
 230   1        TMOD &= 0xF0;   //ËÆæÁΩÆÂÆöÊó∂Âô®Ê®°Âºè
 231   1        TMOD |= 0x01;   //ËÆæÁΩÆÂÆöÊó∂Âô®Ê®°Âºè
 232   1        TL0 = 0x18;   //ËÆæÁΩÆÂÆöÊó∂ÂàùÂßãÂÄº
 233   1        TH0 = 0xFC;   //ËÆæÁΩÆÂÆöÊó∂ÂàùÂßãÂÄº
 234   1        TF0 = 0;    //Ê∏ÖÈô§TF0Ê†áÂøó
 235   1        TR0 = 1;    //ÂÆöÊó∂Âô®0ÂºÄÂßãËÆ°Êó∂
 236   1        ET0 = 1;    //ÂÆöÊó∂Âô®0‰∏≠Êñ≠ÊâìÂºÄ
 237   1        EA = 1;     //ÊÄª‰∏≠Êñ≠ÊâìÂºÄ
 238   1      }
 239          
C51 COMPILER V9.59.0.0   MAIN                                                              01/30/2026 23:49:01 PAGE 5   

 240          
 241          /* ÂÆöÊó∂Âô®0‰∏≠Êñ≠ÊúçÂä°ÂáΩÊï∞ */
 242          void Timer0Server() interrupt 1
 243          {
 244   1        TL0 = 0x18;   //ËÆæÁΩÆÂÆöÊó∂ÂàùÂßãÂÄº
 245   1        TH0 = 0xFC;   //ËÆæÁΩÆÂÆöÊó∂ÂàùÂßãÂÄº   
 246   1        if(++Key_Slow_Down == 10) Key_Slow_Down = 0;//ÈîÆÁõòÂáèÈÄü‰∏ìÁî®
 247   1        if(++Seg_Slow_Down == 50) Seg_Slow_Down = 0;//Êï∞Á†ÅÁÆ°ÂáèÈÄü‰∏ìÁî®
 248   1        if(++Seg_Pos == 6) Seg_Pos = 0;//Êï∞Á†ÅÁÆ°ÊòæÁ§∫‰∏ìÁî®
 249   1        if(++Led_Pos == 8) Led_Pos = 0;//LedÊòæÁ§∫‰∏ìÁî®
 250   1        Led_Disp(Led_Pos,ucLed[Led_Pos]);
 251   1        Seg_Disp(Seg_Pos, Seg_Buf[Seg_Pos], Seg_Point[Seg_Pos]);
 252   1        if(++Time250 ==250)
 253   1        {
 254   2          Time250 = 0;
 255   2          if(Seg_Dis_Mode == 0) Flag_0 ^= 1;
 256   2          if(Seg_Dis_Mode == 2) Flag_2 ^= 1;
 257   2        }
 258   1        
 259   1        
 260   1        
 261   1          
 262   1      
 263   1        
 264   1      }
 265          
 266          /* Main */
 267          void main()
 268          {
 269   1        Timer0Init();
 270   1        while (1)
 271   1        {
 272   2          Key_Proc();
 273   2          Seg_Proc();
 274   2          Led_Proc();
 275   2        }
 276   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    825    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     52       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
