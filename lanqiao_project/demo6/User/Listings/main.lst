C51 COMPILER V9.59.0.0   MAIN                                                              02/03/2026 15:08:24 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keilc51\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* 头文件声明区 */
   2          #include <STC15F2K60S2.H>//单片机寄存器专用头文件
   3          #include <Init.h>//初始化底层驱动专用头文件
   4          #include <Led.h>//Led底层驱动专用头文件
   5          #include <Key.h>//按键底层驱动专用头文件
   6          #include <Seg.h>//数码管底层驱动专用头文件
   7          #include "onewire.h"
   8          
   9          /* 变量声明区 */
  10          unsigned char Key_Val,Key_Down,Key_Old,Key_Up;//按键专用变量
  11          unsigned char Key_Slow_Down;//按键减速专用变量
  12          unsigned char Seg_Buf[8] = {10,10,10,10,10,10,10,10};//数码管显示数据存放数组
  13          unsigned char Seg_Point[8] = {0,0,0,0,0,0,0,0};//数码管小数点数据存放数组
  14          unsigned char Seg_Pos;//数码管扫描专用变量
  15          unsigned int Seg_Slow_Down;//数码管减速专用变量
  16          unsigned char ucLed[8] = {0,0,0,0,0,0,0,0};//Led显示数据存放数组
  17          float t;
  18          unsigned char Display_Mode;//显示模式
  19          bit Mode1_Flag;//模式一闪烁标志位
  20          unsigned int Tick;//计时变量
  21          unsigned char Set_Index;//参数设置索引
  22          unsigned char TMAX = 30;//最大参数
  23          unsigned char TMIN = 20;//最小参数
  24          unsigned char P_DIS[2] = {30,20};//显示数组
  25          unsigned char Error;//参数错误
  26          unsigned int Key_Long;
  27          unsigned int Delay100ms;
  28          unsigned char Led_Pwm;
  29          unsigned char Led_Level;
  30          
  31          /* 键盘处理函数 */
  32          void Key_Proc()
  33          {
  34   1        if(Key_Slow_Down) return;
  35   1        Key_Slow_Down = 1;//键盘减速程序
  36   1      
  37   1        Key_Val = Key_Read();//实时读取键码值
  38   1        Key_Down = Key_Val & (Key_Old ^ Key_Val);//捕捉按键下降沿
  39   1        Key_Up = ~Key_Val & (Key_Old ^ Key_Val);//捕捉按键上降沿
  40   1        Key_Old = Key_Val;//辅助扫描变量
  41   1        switch(Key_Down)
  42   1        {
  43   2          case 12:
  44   2            Display_Mode ++;
  45   2            if(Display_Mode == 2) 
  46   2            {
  47   3              if(P_DIS[0] > P_DIS[1])
  48   3              {
  49   4                TMAX = P_DIS[0];
  50   4                TMIN = P_DIS[1];
  51   4                Display_Mode = 0;
  52   4                Error = 0;
  53   4              }else
  54   3              {
C51 COMPILER V9.59.0.0   MAIN                                                              02/03/2026 15:08:24 PAGE 2   

  55   4                Display_Mode = 0;
  56   4                P_DIS[0] = 30;
  57   4                P_DIS[1] = 20;
  58   4                TMAX = 30;
  59   4                TMIN = 20;
  60   4                Error = 1;
  61   4              }
  62   3            }
  63   2          break;
  64   2          case 13:
  65   2            if(Display_Mode == 1)
  66   2            {
  67   3              Set_Index ++;
  68   3              if(Set_Index == 2) Set_Index = 0;
  69   3            }
  70   2          break;
  71   2          case 14:
  72   2            if(Display_Mode == 1)
  73   2            {
  74   3              switch(Set_Index)
  75   3              {
  76   4                case 0:
  77   4                  P_DIS[0] ++;
  78   4                if(P_DIS[0] >= 70) P_DIS[0] = 70;
  79   4                break;
  80   4                case 1:
  81   4                  P_DIS[1] ++;
  82   4                if(P_DIS[1] >= 70) P_DIS[1] = 70;
  83   4                break;
  84   4              }
  85   3            }
  86   2          break;
  87   2          case 15:
  88   2            if(Display_Mode == 1)
  89   2            {
  90   3              switch(Set_Index)
  91   3              {
  92   4                case 0:
  93   4                  P_DIS[0] --;
  94   4                if(P_DIS[0] <= 10) P_DIS[0] = 10;
  95   4                break;
  96   4                case 1:
  97   4                  P_DIS[1] --;
  98   4                if(P_DIS[1] <= 10) P_DIS[1] = 10;
  99   4                break;
 100   4              }
 101   3            }
 102   2          break;
 103   2          case 16:
 104   2            TMIN = 20;
 105   2            TMAX = 30;
 106   2            P_DIS[0] = 30;
 107   2            P_DIS[1] = 20;
 108   2            Display_Mode = 0;
 109   2          break;
 110   2        }
 111   1      
 112   1        switch(Key_Old)
 113   1          {
 114   2            case 14:
 115   2            if(Key_Long >= 250)
 116   2            {
C51 COMPILER V9.59.0.0   MAIN                                                              02/03/2026 15:08:24 PAGE 3   

 117   3              if(++Delay100ms >= 5)
 118   3              {
 119   4                Delay100ms = 0;
 120   4                  if(Display_Mode == 1)
 121   4                { 
 122   5                  switch(Set_Index)
 123   5                  {
 124   6                    case 0:
 125   6                      P_DIS[0] ++;
 126   6                      if(P_DIS[0] >= 70) P_DIS[0] = 70;
 127   6                    break;
 128   6                    case 1:
 129   6                      P_DIS[1] ++;
 130   6                      if(P_DIS[1] >= 70) P_DIS[1] = 70;
 131   6                    break;
 132   6                  }
 133   5                }
 134   4              }
 135   3            }
 136   2            break;
 137   2            case 15:
 138   2            if(Key_Long >= 250)
 139   2            {
 140   3              if(++Delay100ms >= 5)
 141   3              {
 142   4                Delay100ms = 0;
 143   4                if(Display_Mode == 1)
 144   4                {
 145   5                  switch(Set_Index)
 146   5                  {
 147   6                    case 0:
 148   6                      P_DIS[0] --;
 149   6                      if(P_DIS[0] <= 10) P_DIS[0] = 10;
 150   6                    break;
 151   6                    case 1:
 152   6                      P_DIS[1] --;
 153   6                      if(P_DIS[1] <= 10) P_DIS[1] = 10;
 154   6                    break;
 155   6                  }
 156   5                }
 157   4              }
 158   3            }
 159   2            break;
 160   2        }
 161   1      }
 162          
 163          /* 信息处理函数 */
 164          void Seg_Proc()
 165          {
 166   1        if(Seg_Slow_Down) return;
 167   1        Seg_Slow_Down = 1;//数码管减速程序
 168   1      
 169   1        t = read_t();
 170   1      
 171   1      
 172   1      
 173   1        switch(Display_Mode)
 174   1        {
 175   2          case 0:
 176   2            Seg_Buf[0] = 11;
 177   2            Seg_Buf[1] = 10;
 178   2            Seg_Buf[2] = 10;
C51 COMPILER V9.59.0.0   MAIN                                                              02/03/2026 15:08:24 PAGE 4   

 179   2            Seg_Buf[3] = 10;
 180   2            Seg_Buf[4] = (unsigned char)t / 10 % 10;
 181   2            Seg_Buf[5] = (unsigned char)t % 10;
 182   2            Seg_Point[5] = 1;
 183   2            Seg_Buf[6] = (unsigned int)(t * 10) % 10;
 184   2            Seg_Buf[7] = 11;
 185   2          break;
 186   2          case 1:
 187   2            Seg_Buf[0] = 12;
 188   2            Seg_Buf[1] = 10;
 189   2            Seg_Buf[2] = 10;
 190   2            Seg_Buf[3] = P_DIS[0] /10;
 191   2            Seg_Buf[4] = P_DIS[0] %10;
 192   2            Seg_Buf[5] = 13;
 193   2            Seg_Point[5] = 0;
 194   2            Seg_Buf[6] = P_DIS[1] /10;
 195   2            Seg_Buf[7] = P_DIS[1] %10;
 196   2            if(Mode1_Flag)
 197   2            {
 198   3                if(Set_Index == 0)
 199   3              {
 200   4                Seg_Buf[3] = 10;
 201   4                Seg_Buf[4] = 10;
 202   4              }
 203   3              if(Set_Index == 1)
 204   3              {
 205   4                Seg_Buf[6] = 10;
 206   4                Seg_Buf[7] = 10;
 207   4              }
 208   3            }
 209   2      
 210   2      
 211   2          break;
 212   2        }
 213   1      }
 214          
 215          /* 其他显示函数 */
 216          void Led_Proc()
 217          {
 218   1        if(((unsigned char)t >= TMAX))
 219   1        {
 220   2          ucLed[0] = 1;
 221   2          Led_Level = 3;
 222   2        }else
 223   1        {
 224   2          ucLed[0] = 0;
 225   2        }
 226   1        
 227   1        if((TMIN <= (unsigned char)t) && (TMAX >= (unsigned char)t))
 228   1        {
 229   2          Led_Level = 6;
 230   2          ucLed[1] = 1;
 231   2        }else 
 232   1        {
 233   2          ucLed[1] = 0;
 234   2        }
 235   1      
 236   1        if(((unsigned char)t <= TMIN))
 237   1        {
 238   2          ucLed[2] = 1;
 239   2          Led_Level = 9;
 240   2        }else
C51 COMPILER V9.59.0.0   MAIN                                                              02/03/2026 15:08:24 PAGE 5   

 241   1        {
 242   2          ucLed[2] = 0;
 243   2        }
 244   1        
 245   1        if(Error) ucLed[3] = 1;
 246   1          else  ucLed[3] = 0;
 247   1      }
 248          
 249          /* 定时器0中断初始化函数 */
 250          void Timer0Init(void)   //1毫秒@12.000MHz
 251          {
 252   1        AUXR &= 0x7F;   //定时器时钟12T模式
 253   1        TMOD &= 0xF0;   //设置定时器模式
 254   1        TL0 = 0x18;   //设置定时初始值
 255   1        TH0 = 0xFC;   //设置定时初始值
 256   1        TF0 = 0;    //清除TF0标志
 257   1        TR0 = 1;    //定时器0开始计时
 258   1        ET0 = 1;    //定时器中断0打开
 259   1        EA = 1;     //总中断打开
 260   1      }
 261          
 262          /* 定时器0中断服务函数 */
 263          void Timer0Server() interrupt 1
 264          {  
 265   1        if(++Key_Slow_Down == 10) Key_Slow_Down = 0;//键盘减速专用
 266   1        if(++Seg_Slow_Down == 50) Seg_Slow_Down = 0;//数码管减速专用
 267   1        if(++Seg_Pos == 8) Seg_Pos = 0;//数码管显示专用
 268   1        Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);
 269   1        
 270   1        if(Display_Mode == 1)
 271   1        {
 272   2            if(++Tick == 250)
 273   2          {
 274   3            Tick = 0;
 275   3            Mode1_Flag ^= 1;
 276   3          }
 277   2        }
 278   1        if((Key_Old == 14) || (Key_Old == 15))
 279   1        {
 280   2          if(++Key_Long == 65535) Key_Long = 0;
 281   2        }else
 282   1        {
 283   2          Key_Long = 0;
 284   2        }
 285   1        if(++Led_Pwm == 12) Led_Pwm = 12;
 286   1        if(Led_Pwm < Led_Level)
 287   1          Led_Disp(Seg_Pos,ucLed[Seg_Pos]);
 288   1        else
 289   1          Led_Disp(Seg_Pos,0);
 290   1      
 291   1      }
 292          void Delay750ms()   //@12.000MHz
 293          {
 294   1        unsigned char i, j, k;
 295   1        i = 35;
 296   1        j = 51;
 297   1        k = 182;
 298   1        do
 299   1        {
 300   2          do
 301   2          {
 302   3            while (--k);
C51 COMPILER V9.59.0.0   MAIN                                                              02/03/2026 15:08:24 PAGE 6   

 303   3          } while (--j);
 304   2        } while (--i);
 305   1      }
 306          
 307          /* Main */
 308          void main()
 309          {
 310   1        read_t();
 311   1        Delay750ms();
 312   1        System_Init();
 313   1        Timer0Init();
 314   1        while (1)
 315   1        {
 316   2          Key_Proc();
 317   2          Seg_Proc();
 318   2          Led_Proc();
 319   2        }
 320   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    992    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     51    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
