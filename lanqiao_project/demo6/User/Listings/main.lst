C51 COMPILER V9.59.0.0   MAIN                                                              02/02/2026 19:00:26 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keilc51\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* 头文件声明区 */
   2          #include <STC15F2K60S2.H>//单片机寄存器专用头文件
   3          #include <Init.h>//初始化底层驱动专用头文件
   4          #include <Led.h>//Led底层驱动专用头文件
   5          #include <Key.h>//按键底层驱动专用头文件
   6          #include <Seg.h>//数码管底层驱动专用头文件
   7          #include "onewire.h"
   8          
   9          /* 变量声明区 */
  10          unsigned char Key_Val,Key_Down,Key_Old,Key_Up;//按键专用变量
  11          unsigned char Key_Slow_Down;//按键减速专用变量
  12          unsigned char Seg_Buf[8] = {10,10,10,10,10,10,10,10};//数码管显示数据存放数组
  13          unsigned char Seg_Point[8] = {0,0,0,0,0,0,0,0};//数码管小数点数据存放数组
  14          unsigned char Seg_Pos;//数码管扫描专用变量
  15          unsigned int Seg_Slow_Down;//数码管减速专用变量
  16          unsigned char ucLed[8] = {0,0,0,0,0,0,0,0};//Led显示数据存放数组
  17          float t;
  18          unsigned char Display_Mode;//显示模式
  19          bit Mode1_Flag;//模式一闪烁标志位
  20          unsigned int Tick;//计时变量
  21          unsigned char Set_Index;//参数设置索引
  22          unsigned char TMAX = 30;//最大参数
  23          unsigned char TMIN = 20;//最小参数
  24          unsigned char Led_Level[8] = {0,0,0,0,0,0,0,0};//每个LED独立的亮度等级(0-5)
  25          unsigned char Led_PWM_Counter[8] = {0,0,0,0,0,0,0,0};//每个LED独立的PWM计数器(0-4循环)
  26          unsigned char Error;//参数错误
  27          
  28          /* 键盘处理函数 */
  29          void Key_Proc()
  30          {
  31   1        if(Key_Slow_Down) return;
  32   1        Key_Slow_Down = 1;//键盘减速程序
  33   1      
  34   1        Key_Val = Key_Read();//实时读取键码值
  35   1        Key_Down = Key_Val & (Key_Old ^ Key_Val);//捕捉按键下降沿
  36   1        Key_Up = ~Key_Val & (Key_Old ^ Key_Val);//捕捉按键上降沿
  37   1        Key_Old = Key_Val;//辅助扫描变量
  38   1        switch(Key_Down)
  39   1        {
  40   2          case 12:
  41   2            Display_Mode ++;
  42   2            if(Display_Mode == 2) 
  43   2            {
  44   3              if(TMAX > TMIN)
  45   3              {
  46   4                Display_Mode = 0;
  47   4                Error = 0;
  48   4              }else
  49   3              {
  50   4                Display_Mode = 0;
  51   4                TMAX = 30;
  52   4                TMIN = 20;
  53   4                Error = 1;
  54   4              }
C51 COMPILER V9.59.0.0   MAIN                                                              02/02/2026 19:00:26 PAGE 2   

  55   3            }
  56   2          break;
  57   2          case 13:
  58   2            if(Display_Mode == 1)
  59   2            {
  60   3              Set_Index ++;
  61   3              if(Set_Index == 2) Set_Index = 0;
  62   3            }
  63   2          break;
  64   2          case 14:
  65   2            if(Display_Mode == 1)
  66   2            {
  67   3              switch(Set_Index)
  68   3              {
  69   4                case 0:
  70   4                  TMAX ++;
  71   4                if(TMAX >= 70) TMAX = 70;
  72   4                break;
  73   4                case 1:
  74   4                  TMIN ++;
  75   4                if(TMIN >= 70) TMIN = 70;
  76   4                break;
  77   4              }
  78   3            }
  79   2          break;
  80   2          case 15:
  81   2            if(Display_Mode == 1)
  82   2            {
  83   3              switch(Set_Index)
  84   3              {
  85   4                case 0:
  86   4                  TMAX --;
  87   4                if(TMAX <= 10) TMAX = 10;
  88   4                break;
  89   4                case 1:
  90   4                  TMIN --;
  91   4                if(TMIN <= 10) TMIN = 10;
  92   4                break;
  93   4              }
  94   3            }
  95   2          break;
  96   2          case 16:
  97   2            TMIN = 20;
  98   2            TMAX = 30;
  99   2            Display_Mode = 0;
 100   2          break;
 101   2        }
 102   1      
 103   1      }
 104          
 105          /* 信息处理函数 */
 106          void Seg_Proc()
 107          {
 108   1        if(Seg_Slow_Down) return;
 109   1        Seg_Slow_Down = 1;//数码管减速程序
 110   1      
 111   1        t = read_t();
 112   1      
 113   1      
 114   1      
 115   1        switch(Display_Mode)
 116   1        {
C51 COMPILER V9.59.0.0   MAIN                                                              02/02/2026 19:00:26 PAGE 3   

 117   2          case 0:
 118   2            Seg_Buf[0] = 11;
 119   2            Seg_Buf[1] = 10;
 120   2            Seg_Buf[2] = 10;
 121   2            Seg_Buf[3] = 10;
 122   2            Seg_Buf[4] = (unsigned char)t / 10 % 10;
 123   2            Seg_Buf[5] = (unsigned char)t % 10;
 124   2            Seg_Point[5] = 1;
 125   2            Seg_Buf[6] = (unsigned int)(t * 10) % 10;
 126   2            Seg_Buf[7] = 11;
 127   2          break;
 128   2          case 1:
 129   2            Seg_Buf[0] = 12;
 130   2            Seg_Buf[1] = 10;
 131   2            Seg_Buf[2] = 10;
 132   2            Seg_Buf[3] = TMAX /10;
 133   2            Seg_Buf[4] = TMAX %10;
 134   2            Seg_Buf[5] = 13;
 135   2            Seg_Point[5] = 0;
 136   2            Seg_Buf[6] = TMIN /10;
 137   2            Seg_Buf[7] = TMIN %10;
 138   2            if(Mode1_Flag)
 139   2            {
 140   3                if(Set_Index == 0)
 141   3              {
 142   4                Seg_Buf[3] = 10;
 143   4                Seg_Buf[4] = 10;
 144   4              }
 145   3              if(Set_Index == 1)
 146   3              {
 147   4                Seg_Buf[6] = 10;
 148   4                Seg_Buf[7] = 10;
 149   4              }
 150   3            }
 151   2      
 152   2      
 153   2          break;
 154   2        }
 155   1      }
 156          
 157          /* 其他显示函数 */
 158          void Led_Proc()
 159          {
 160   1      //  if((unsigned char) t > TMAX)
 161   1      //  {
 162   1      //    Led_Level[0] = 1;  // LED1亮度等级1 (20%占空比 - 超温微亮提示)
 163   1      //    ucLed[0] = 1;
 164   1      //  }else
 165   1      //  {
 166   1      //    ucLed[0] = 0;
 167   1      //  }
 168   1      //  if((unsigned char) t < TMIN)
 169   1      //  {
 170   1      //    Led_Level[2] = 4;  // LED3亮度等级4 (80%占空比 - 低温高亮警告)
 171   1      //    ucLed[2] = 1;
 172   1      //  }else
 173   1      //  {
 174   1      //    ucLed[2] = 0;
 175   1      //  }
 176   1      //  if(((unsigned char) t <= TMAX) && ((unsigned char) t >= TMIN))
 177   1      //  {
 178   1      //    Led_Level[1] = 2;  // LED2亮度等级2 (40%占空比 - 正常中等亮度)
C51 COMPILER V9.59.0.0   MAIN                                                              02/02/2026 19:00:26 PAGE 4   

 179   1      //    ucLed[1] = 1;
 180   1      //  }else
 181   1      //  {
 182   1      //    ucLed[1] = 0;
 183   1      //  }
 184   1      //  if(Error)
 185   1      //  {
 186   1      //    Led_Level[3] = 5;  // LED4亮度等级5 (100%全亮 - 错误刺眼告警)
 187   1      //    ucLed[3] = 1;
 188   1      //  }else
 189   1      //  {
 190   1      //    ucLed[3] = 0;
 191   1      //  }
 192   1      }
 193          
 194          /* 定时器0中断初始化函数 */
 195          void Timer0Init(void)   //1毫秒@12.000MHz
 196          {
 197   1        AUXR &= 0x7F;   //定时器时钟12T模式
 198   1        TMOD &= 0xF0;   //设置定时器模式
 199   1        TL0 = 0x18;   //设置定时初始值
 200   1        TH0 = 0xFC;   //设置定时初始值
 201   1        TF0 = 0;    //清除TF0标志
 202   1        TR0 = 1;    //定时器0开始计时
 203   1        ET0 = 1;    //定时器中断0打开
 204   1        EA = 1;     //总中断打开
 205   1      }
 206          
 207          /* 定时器0中断服务函数 */
 208          void Timer0Server() interrupt 1
 209          {  
 210   1        if(++Key_Slow_Down == 10) Key_Slow_Down = 0;//键盘减速专用
 211   1        if(++Seg_Slow_Down == 50) Seg_Slow_Down = 0;//数码管减速专用
 212   1        if(++Seg_Pos == 8) Seg_Pos = 0;//数码管显示专用
 213   1        Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);
 214   1        
 215   1        if(Display_Mode == 1)
 216   1        {
 217   2            if(++Tick == 250)
 218   2          {
 219   3            Tick = 0;
 220   3            Mode1_Flag ^= 1;
 221   3          }
 222   2        }
 223   1      
 224   1      //  // LED独立PWM控制 - 同时处理所有LED(静态显示模式)
 225   1      //  // PWM周期5ms, 频率200Hz, 5级亮度调节(0-5)
 226   1      //  {
 227   1      //    unsigned char i;
 228   1      //    // 更新所有LED的PWM计数器 (0-4循环，周期5ms)
 229   1      //    for(i = 0; i < 8; i++)
 230   1      //    {
 231   1      //      if(++Led_PWM_Counter[i] == 5)
 232   1      //        Led_PWM_Counter[i] = 0;
 233   1      
 234   1      //      // 根据PWM占空比决定该LED状态
 235   1      //      // Led_Level范围0-5: 0=关闭, 1=20%, 2=40%, 3=60%, 4=80%, 5=100%
 236   1      //      if(Led_PWM_Counter[i] < Led_Level[i] && ucLed[i])
 237   1      //        Led_Disp(i, 1);
 238   1      //      else
 239   1      //        Led_Disp(i, 0);
 240   1      //    }
C51 COMPILER V9.59.0.0   MAIN                                                              02/02/2026 19:00:26 PAGE 5   

 241   1      //  }
 242   1      }
 243          void Delay750ms()   //@12.000MHz
 244          {
 245   1        unsigned char i, j, k;
 246   1        i = 35;
 247   1        j = 51;
 248   1        k = 182;
 249   1        do
 250   1        {
 251   2          do
 252   2          {
 253   3            while (--k);
 254   3          } while (--j);
 255   2        } while (--i);
 256   1      }
 257          
 258          /* Main */
 259          void main()
 260          {
 261   1        read_t();
 262   1        Delay750ms();
 263   1        System_Init();
 264   1        Timer0Init();
 265   1        while (1)
 266   1        {
 267   2          Key_Proc();
 268   2          Seg_Proc();
 269   2          Led_Proc();
 270   2        }
 271   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    615    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     59    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
