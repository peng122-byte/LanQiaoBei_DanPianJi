C51 COMPILER V9.59.0.0   MAIN                                                              01/28/2026 18:16:10 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keilc51\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* å¤´æ–‡ä»¶å£°æ˜åŒº */
   2          #include <REGX52.H>//å•ç‰‡æœºå¯„å­˜å™¨ä¸“ç”¨å¤´æ–‡ä»¶
   3          #include <Key.h>//æŒ‰é”®åº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
   4          #include <Seg.h>//æ•°ç ç®¡åº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
   5          #include <intrins.h>
   6          #include <Led.h>
   7          /* å˜é‡å£°æ˜åŒº */
   8          unsigned char Key_Val,Key_Down,Key_Old,Key_Up;//æŒ‰é”®ä¸“ç”¨å˜é‡
   9          unsigned char Key_Slow_Down;//æŒ‰é”®å‡é€Ÿä¸“ç”¨å˜é‡
  10          unsigned char Seg_Buf[6] = {10,10,13,13,13,13};//æ•°ç ç®¡æ˜¾ç¤ºæ•°æ®å­˜æ”¾æ•°ç»„
  11          unsigned char Seg_Point[6] = {0,0,0,0,0,0};//æ•°ç ç®¡å°æ•°ç‚¹æ•°æ®å­˜æ”¾æ•°ç»„
  12          unsigned char Seg_Pos;//æ•°ç ç®¡æ‰«æä¸“ç”¨å˜é‡
  13          unsigned int  Seg_Slow_Down;//æ•°ç ç®¡å‡é€Ÿä¸“ç”¨å˜é‡
  14          unsigned char Disp_Mode = 0;//æ•°ç ç®¡æ˜¾ç¤ºæ¨¡å¼ï¼š0-ç”µå‹é‡‡é›†  1-æ•°æ®æ˜¾ç¤º  2-å‚æ•°è®¾ç½® 3-è®¡æ•
             -°ç»Ÿè®¡
  15          unsigned char Voltage_Input [4] ={13,13,13,13};//ç”µå‹è¾“å…¥æ•°ç»„
  16          unsigned char Voltage_Data [4] ={0,0,0,0};//ç”µå‹é‡‡é›†æ•°æ®æ•°ç»„
  17          unsigned char Voltage_Input_Index;//ç”µå‹æ•°æ®è¾“å…¥ç´¢å¼•
  18          unsigned char Voltage_Data_Index;//ç”µå‹æ•°æ®ç´¢å¼•
  19          unsigned int  Timer250;//500msé—ªçƒè®¡æ—¶
  20          bit Input_Flag;//é—ªçƒæ ‡å¿—ä½
  21          unsigned char Voltage_Val;//è¾“å…¥ç”µå‹å€¼
  22          unsigned char Key_Error_Count;//æŒ‰é”®æº¢å‡ºå˜é‡
  23          unsigned char Voltage_Setting_Data [3] ={3,0,0};//ç”µå‹å‚æ•°è®¾ç½®æ•°ç»„
  24          unsigned int Voltage_Setting;//ç”µå‹è®¾ç½®
  25          unsigned char Voltage_Setting_Data_Index;//ç”µå‹å‚æ•°è®¾ç½®æ•°ç»„ç´¢å¼•
  26          unsigned char Voltage_Real_Data [3] = {0,0,0};//ç”µå‹å®é™…å€¼
  27          unsigned int  Voltage_Real = 0;//ç”µå‹çœŸå®å€¼
  28          unsigned int  Voltage_Old = 0;//ç”µå‹çœŸå®å€¼Old
  29          unsigned int  Voltage_Count = 0;//ç”µå‹è®¡æ•°
  30          unsigned char ucLed[8] ={0,0,0,0,0,0,0,0};//Led
  31          unsigned char Led_Pos;
  32          unsigned int  Sys_Tick;
  33          /* é”®ç›˜å¤„ç†å‡½æ•° */
  34          void Key_Proc()
  35          {
  36   1        unsigned char i;
  37   1        if (Key_Slow_Down) return;
  38   1        Key_Slow_Down = 1;//æŒ‰é”®å‡é€Ÿç¨‹åº
  39   1        
  40   1        Key_Val = Key_Read();//è¯»å–æŒ‰ä¸‹çš„é”®å€¼
  41   1        Key_Down = Key_Val & (Key_Val ^ Key_Old);//ä¸‹é™æ²¿
  42   1        Key_Up = Key_Old & (Key_Val ^ Key_Old);//ä¸Šå‡æ²¿
  43   1        
  44   1        Key_Old = Key_Val;//è¾…åŠ©æ‰«æ
  45   1        
  46   1        
  47   1        if((Key_Down >= 1) && (Key_Down <= 10))
  48   1        {
  49   2          if(Voltage_Input_Index < 4)  // æ”¹ä¸º < 4ï¼Œé˜²æ­¢è¶Šç•Œ
  50   2          {
  51   3            Key_Error_Count = 0;
  52   3            if(Disp_Mode == 0)
  53   3            {
C51 COMPILER V9.59.0.0   MAIN                                                              01/28/2026 18:16:10 PAGE 2   

  54   4              Voltage_Val = Key_Down - 1;
  55   4              Voltage_Input[Voltage_Input_Index] = Voltage_Val;
  56   4              Voltage_Input_Index ++;
  57   4              Key_Error_Count = 0;
  58   4            }else
  59   3            {
  60   4              Key_Error_Count ++;
  61   4            }
  62   3          }
  63   2        }
  64   1      
  65   1        // æŒ‰é”®11ç¡®è®¤ï¼šç‹¬ç«‹åˆ¤æ–­ï¼Œä¸å—è¾“å…¥ç´¢å¼•é™åˆ¶
  66   1        if(Key_Down == 11)
  67   1        {
  68   2          if(Disp_Mode == 0)
  69   2          {
  70   3              if(Voltage_Input_Index == 4)
  71   3            {
  72   4              Key_Error_Count = 0;
  73   4              // 1. ä¿å­˜æ—§ç”µå‹å€¼ç”¨äºä¸‹é™æ²¿æ£€æµ‹
  74   4              Voltage_Old = Voltage_Real;
  75   4              // 2. å¤åˆ¶æ–°è¾“å…¥æ•°æ®
  76   4              for(i = 0;i<4;i++)
  77   4              {
  78   5                Voltage_Data[i] = Voltage_Input[i];
  79   5              }
  80   4              // 3. ç«‹å³è®¡ç®—å››èˆäº”å…¥å€¼ï¼ˆå¤åˆ¶Seg_Procæ¨¡å¼1çš„é€»è¾‘ï¼‰
  81   4              Voltage_Real_Data[0] = Voltage_Data[0];
  82   4              Voltage_Real_Data[1] = Voltage_Data[1];
  83   4              Voltage_Real_Data[2] = Voltage_Data[2];
  84   4              if(Voltage_Data[3] >= 5)  // ç¬¬4ä½å››èˆäº”å…¥
  85   4              {
  86   5                Voltage_Real_Data[2]++;
  87   5                if(Voltage_Real_Data[2] >= 10)
  88   5                {
  89   6                  Voltage_Real_Data[2] = 0;
  90   6                  Voltage_Real_Data[1]++;
  91   6                }
  92   5                if(Voltage_Real_Data[1] >= 10)
  93   5                {
  94   6                  Voltage_Real_Data[1] = 0;
  95   6                  Voltage_Real_Data[0]++;
  96   6                }
  97   5              }
  98   4              Voltage_Real = Voltage_Real_Data[2] + 10*Voltage_Real_Data[1] + 100*Voltage_Real_Data[0];
  99   4              // 4. ä¸‹é™æ²¿æ£€æµ‹ï¼šä¸Šæ¬¡>=é˜ˆå€¼ ä¸” å½“å‰<é˜ˆå€¼
 100   4              Voltage_Setting = Voltage_Setting_Data[2] + 10*Voltage_Setting_Data[1] + 100*Voltage_Setting_Data[0];
 101   4              if((Voltage_Real < Voltage_Setting) && (Voltage_Old >= Voltage_Setting))
 102   4              {
 103   5                Voltage_Count++;
 104   5              }
 105   4              Disp_Mode = 1;
 106   4            }else
 107   3            {
 108   4              Key_Error_Count ++;
 109   4            }
 110   3          }else 
 111   2          {
 112   3            Voltage_Input_Index = 0;
 113   3            for(i = 0;i<4;i++)
 114   3            {
 115   4              Voltage_Input[i] = 13;
C51 COMPILER V9.59.0.0   MAIN                                                              01/28/2026 18:16:10 PAGE 3   

 116   4            }
 117   3            Disp_Mode = 0;
 118   3          }
 119   2        }
 120   1        if(Key_Down == 12)
 121   1        { 
 122   2          if(Disp_Mode != 0)
 123   2          {
 124   3            Key_Error_Count = 0;
 125   3            if(++ Disp_Mode == 4) Disp_Mode = 1;
 126   3          }else
 127   2          {
 128   3            Key_Error_Count ++;
 129   3          }
 130   2        }   
 131   1        if(Key_Down == 15)
 132   1        {
 133   2          if(Disp_Mode == 2)
 134   2          {
 135   3            Key_Error_Count = 0;
 136   3            Voltage_Setting_Data[1] += 5;
 137   3            if( Voltage_Setting_Data[1] == 10)  
 138   3            {
 139   4              Voltage_Setting_Data[1] = 0;
 140   4              Voltage_Setting_Data[0] += 1;
 141   4            }
 142   3            if((Voltage_Setting_Data[0] == 6) && (Voltage_Setting_Data[1] == 5))
 143   3            { 
 144   4              Voltage_Setting_Data[0] = 1;
 145   4              Voltage_Setting_Data[1] = 0;
 146   4            }
 147   3          }else
 148   2          {
 149   3            Key_Error_Count ++;
 150   3          }
 151   2        }
 152   1        if(Key_Down == 16)
 153   1        {
 154   2          if(Disp_Mode == 2)
 155   2          {
 156   3            Key_Error_Count = 0;
 157   3            if( Voltage_Setting_Data[1] == 0) 
 158   3            {
 159   4              Voltage_Setting_Data[1] = 5;
 160   4              Voltage_Setting_Data[0] -= 1;
 161   4            }else
 162   3            {
 163   4              Voltage_Setting_Data[1] -= 5;
 164   4              
 165   4            }
 166   3            if((Voltage_Setting_Data[0] == 0) && (Voltage_Setting_Data[1] == 5))  
 167   3            {
 168   4              Voltage_Setting_Data[1] = 0;
 169   4              Voltage_Setting_Data[0] = 6;
 170   4            }
 171   3          }else
 172   2          {
 173   3            Key_Error_Count ++;
 174   3          }
 175   2        }
 176   1      }
 177          
C51 COMPILER V9.59.0.0   MAIN                                                              01/28/2026 18:16:10 PAGE 4   

 178          /* ä¿¡æ¯å¤„ç†å‡½æ•° */
 179          void Seg_Proc()
 180          {
 181   1        unsigned char i;
 182   1        if (Seg_Slow_Down) return;
 183   1        Seg_Slow_Down =1 ;
 184   1        switch(Disp_Mode)
 185   1        {
 186   2          case 0:
 187   2            Seg_Buf[0] = 10;
 188   2            Seg_Buf[1] = 10;
 189   2            // æ˜¾ç¤ºå·²è¾“å…¥çš„4ä½æ•°æ®
 190   2            
 191   2            Seg_Buf[2] = Voltage_Input[0];
 192   2            Seg_Buf[3] = Voltage_Input[1];
 193   2            Seg_Point[3] = 0;
 194   2            Seg_Buf[4] = Voltage_Input[2];
 195   2            Seg_Buf[5] = Voltage_Input[3];
 196   2            // å½“å‰è¾“å…¥ä½é—ªçƒï¼ˆåªåœ¨æœªè¾“å…¥æ»¡4ä½æ—¶é—ªçƒï¼‰é‡è¦ï¼ï¼ï¼
 197   2            if(Voltage_Input_Index < 4 && Input_Flag == 1)
 198   2            {
 199   3              Seg_Buf[Voltage_Input_Index + 2] = 10;
 200   3            }
 201   2          break;
 202   2          case 1:
 203   2            Seg_Buf[0] = 14;
 204   2            Seg_Buf[1] = 10;
 205   2            Seg_Buf[2] = 10;
 206   2            Seg_Buf[3] = Voltage_Data[0];
 207   2            Seg_Point[3] = 1;
 208   2            Seg_Buf[4] = Voltage_Data[1];
 209   2            Seg_Buf[5] = Voltage_Data[2];
 210   2            if(Voltage_Data[3] >= 5)  
 211   2            {
 212   3              Seg_Buf[5] = Voltage_Data[2] + 1;
 213   3            }
 214   2            if(Seg_Buf[5] >= 10)
 215   2            {
 216   3              Seg_Buf[5] = 0;
 217   3              Seg_Buf[4] = Voltage_Data[1] + 1;
 218   3            }
 219   2            if(Seg_Buf[4] >= 10)
 220   2            {
 221   3              Seg_Buf[4] = 0;
 222   3              Seg_Buf[3] = Voltage_Data[0] + 1;
 223   3            }
 224   2            if(Seg_Buf[3] == 10)
 225   2            {
 226   3              Seg_Buf[3] = 0;
 227   3              Seg_Buf[2] = 1;
 228   3            }
 229   2          break;
 230   2          case 2:
 231   2            Seg_Buf[0] = 15;
 232   2            Seg_Buf[1] = 10;
 233   2            Seg_Buf[2] = 10;
 234   2            Seg_Buf[3] = Voltage_Setting_Data[0];
 235   2            Seg_Point[3] = 1;
 236   2            Seg_Buf[4] = Voltage_Setting_Data[1];
 237   2            Seg_Buf[5] = Voltage_Setting_Data[2];
 238   2          break;
 239   2          case 3:
C51 COMPILER V9.59.0.0   MAIN                                                              01/28/2026 18:16:10 PAGE 5   

 240   2            Seg_Buf[0] =  16; 
 241   2            Seg_Buf[1] =  Voltage_Count / 10000 %10;
 242   2            Seg_Buf[2] =  Voltage_Count / 1000 %10;
 243   2            Seg_Buf[3] =  Voltage_Count / 100 %10;
 244   2            Seg_Point[3] = 0;
 245   2            Seg_Buf[4] =  Voltage_Count / 10 %10;
 246   2            Seg_Buf[5] =  Voltage_Count %10;
 247   2            for(i= 0;i<5;i++)
 248   2            {
 249   3              if(Seg_Buf[i] == 0) Seg_Buf[i] = 10;
 250   3            }
 251   2          break;
 252   2        }
 253   1      }
 254          /* å…¶ä»–æ˜¾ç¤ºå‡½æ•° */
 255          void Led_Proc()
 256          {
 257   1        if(Sys_Tick >= 5000)
 258   1        {
 259   2          ucLed[0] = 1;
 260   2        }else
 261   1        {
 262   2          ucLed[0] = 0;
 263   2        }
 264   1        if((Voltage_Count %2) != 0)
 265   1        {
 266   2          ucLed[1] = 1;
 267   2        }else
 268   1        {
 269   2          ucLed[1] = 0;
 270   2        }
 271   1        if(Key_Error_Count == 3)
 272   1        {
 273   2          ucLed[2] = 1;
 274   2        }else if(Key_Error_Count == 0)
 275   1        {
 276   2          ucLed[2] = 0;
 277   2        }
 278   1      }
 279          
 280          
 281          
 282          
 283          /* å®šæ—¶å™¨0ä¸­æ–­åˆå§‹åŒ–å‡½æ•° */
 284          void Timer0Init(void)   //1æ¯«ç§’@12.000MHz
 285          {
 286   1        TMOD &= 0xF0;   //è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 287   1        TMOD |= 0x01;   //è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 288   1        TL0 = 0x18;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 289   1        TH0 = 0xFC;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 290   1        TF0 = 0;    //æ¸…é™¤TF0æ ‡å¿—
 291   1        TR0 = 1;    //å®šæ—¶å™¨0å¼€å§‹è®¡æ—¶
 292   1        ET0 = 1;    //å®šæ—¶å™¨0ä¸­æ–­æ‰“å¼€
 293   1        EA = 1;     //æ€»ä¸­æ–­æ‰“å¼€
 294   1      }
 295          
 296          
 297          /* å®šæ—¶å™¨0ä¸­æ–­æœåŠ¡å‡½æ•° */
 298          void Timer0Server() interrupt 1
 299          {
 300   1        TL0 = 0x18;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 301   1        TH0 = 0xFC;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼   
C51 COMPILER V9.59.0.0   MAIN                                                              01/28/2026 18:16:10 PAGE 6   

 302   1        if(++Key_Slow_Down == 10) Key_Slow_Down = 0;//é”®ç›˜å‡é€Ÿä¸“ç”¨
 303   1        if(++Seg_Slow_Down == 50) Seg_Slow_Down = 0;//æ•°ç ç®¡å‡é€Ÿä¸“ç”¨
 304   1        if(++Seg_Pos == 6) Seg_Pos = 0;//æ•°ç ç®¡æ˜¾ç¤ºä¸“ç”¨
 305   1        Seg_Disp(Seg_Pos, Seg_Buf[Seg_Pos], Seg_Point[Seg_Pos]);
 306   1        if(++Led_Pos == 8) Led_Pos = 0;
 307   1        Led_Disp(Led_Pos,ucLed[Led_Pos]);
 308   1        if (++ Timer250 == 250)
 309   1        {
 310   2          Timer250 = 0;
 311   2          Input_Flag ^= 1;
 312   2        }
 313   1        if(Voltage_Real < Voltage_Setting)
 314   1        {
 315   2          Sys_Tick ++;
 316   2        }
 317   1        
 318   1        
 319   1          
 320   1      
 321   1        
 322   1      }
 323          
 324          /* Main */
 325          void main()
 326          {
 327   1        Timer0Init();
 328   1        while (1)
 329   1        {
 330   2          
 331   2          Key_Proc();
 332   2          Seg_Proc();
 333   2          Led_Proc();
 334   2        }
 335   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1071    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     61       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
