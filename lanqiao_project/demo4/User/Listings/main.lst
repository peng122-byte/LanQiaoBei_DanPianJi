C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2026 00:37:41 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keilc51\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* å¤´æ–‡ä»¶å£°æ˜åŒº */
   2          #include <REGX52.H>//å•ç‰‡æœºå¯„å­˜å™¨ä¸“ç”¨å¤´æ–‡ä»¶
   3          #include <Key.h>//æŒ‰é”®åº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
   4          #include <Seg.h>//æ•°ç ç®¡åº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
   5          #include <intrins.h>
   6          #include <Led.h>
   7          /* å˜é‡å£°æ˜åŒº */
   8          unsigned char Key_Val,Key_Down,Key_Old,Key_Up;//æŒ‰é”®ä¸“ç”¨å˜é‡
   9          unsigned char Key_Slow_Down;//æŒ‰é”®å‡é€Ÿä¸“ç”¨å˜é‡
  10          unsigned char Seg_Buf[6] = {10,10,13,13,13,13};//æ•°ç ç®¡æ˜¾ç¤ºæ•°æ®å­˜æ”¾æ•°ç»„
  11          unsigned char Seg_Point[6] = {0,0,0,0,0,0};//æ•°ç ç®¡å°æ•°ç‚¹æ•°æ®å­˜æ”¾æ•°ç»„
  12          unsigned char Seg_Pos;//æ•°ç ç®¡æ‰«æä¸“ç”¨å˜é‡
  13          unsigned int Seg_Slow_Down;//æ•°ç ç®¡å‡é€Ÿä¸“ç”¨å˜é‡
  14          unsigned char Disp_Mode = 0;//æ•°ç ç®¡æ˜¾ç¤ºæ¨¡å¼ï¼š0-ç”µå‹é‡‡é›†  1-æ•°æ®æ˜¾ç¤º  2-å‚æ•°è®¾ç½® 3-è®¡æ•
             -°ç»Ÿè®¡
  15          unsigned char Voltage_Input [4] ={13,13,13,13};//ç”µå‹è¾“å…¥æ•°ç»„
  16          unsigned char Voltage_Data [4] ={0,0,0,0};//ç”µå‹é‡‡é›†æ•°æ®æ•°ç»„
  17          unsigned char Voltage_Input_Index;//ç”µå‹æ•°æ®è¾“å…¥ç´¢å¼•
  18          unsigned char Voltage_Data_Index;//ç”µå‹æ•°æ®ç´¢å¼•
  19          unsigned int Timer250;//500msé—ªçƒè®¡æ—¶
  20          bit Input_Flag;//é—ªçƒæ ‡å¿—ä½
  21          unsigned char Voltage_Val;//è¾“å…¥ç”µå‹å€¼
  22          unsigned char Key_Error_Count;//æŒ‰é”®æº¢å‡ºå˜é‡
  23          
  24          /* é”®ç›˜å¤„ç†å‡½æ•° */
  25          void Key_Proc()
  26          {
  27   1        unsigned char i;
  28   1        if (Key_Slow_Down) return;
  29   1        Key_Slow_Down = 1;//æŒ‰é”®å‡é€Ÿç¨‹åº
  30   1        
  31   1        Key_Val = Key_Read();//è¯»å–æŒ‰ä¸‹çš„é”®å€¼
  32   1        Key_Down = Key_Val & (Key_Val ^ Key_Old);//ä¸‹é™æ²¿
  33   1        Key_Up = Key_Old & (Key_Val ^ Key_Old);//ä¸Šå‡æ²¿
  34   1        
  35   1        Key_Old = Key_Val;//è¾…åŠ©æ‰«æ
  36   1        
  37   1        
  38   1        if(Disp_Mode == 0)
  39   1        {
  40   2          if(Voltage_Input_Index < 4)  // æ”¹ä¸º < 4ï¼Œé˜²æ­¢è¶Šç•Œ
  41   2          {
  42   3            if((Key_Down >= 1) && (Key_Down <= 10))
  43   3            {
  44   4              Voltage_Val = Key_Down - 1;
  45   4              Voltage_Input[Voltage_Input_Index] = Voltage_Val;
  46   4              Voltage_Input_Index ++;
  47   4              Key_Error_Count = 0;
  48   4            }else
  49   3            {
  50   4            Key_Error_Count ++;
  51   4            }
  52   3          }
  53   2      
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2026 00:37:41 PAGE 2   

  54   2          // æŒ‰é”®11ç¡®è®¤ï¼šç‹¬ç«‹åˆ¤æ–­ï¼Œä¸å—è¾“å…¥ç´¢å¼•é™åˆ¶
  55   2          if((Key_Down == 11) && (Voltage_Input_Index == 4) )
  56   2          {
  57   3            for(i = 0;i<4;i++)
  58   3            {
  59   4              Voltage_Data[i] = Voltage_Input[i];
  60   4            }
  61   3            Disp_Mode = 1;
  62   3          }
  63   2        }
  64   1        
  65   1        
  66   1        if(Key_Down == 12)
  67   1        {
  68   2          if(++ Disp_Mode == 4) Disp_Mode = 0;
  69   2        }
  70   1        
  71   1        
  72   1        
  73   1        
  74   1        
  75   1        
  76   1        
  77   1        
  78   1        
  79   1        
  80   1      }
  81          
  82          
  83          
  84          
  85          /* ä¿¡æ¯å¤„ç†å‡½æ•° */
  86          void Seg_Proc()
  87          {
  88   1        if (Seg_Slow_Down) return;
  89   1        Seg_Slow_Down =1 ;
  90   1        switch(Disp_Mode)
  91   1        {
  92   2          case 0:
  93   2            Seg_Buf[0] = 10;
  94   2            Seg_Buf[1] = 10;
  95   2            // æ˜¾ç¤ºå·²è¾“å…¥çš„4ä½æ•°æ®
  96   2            Seg_Buf[2] = Voltage_Input[0];
  97   2            Seg_Buf[3] = Voltage_Input[1];
  98   2            Seg_Buf[4] = Voltage_Input[2];
  99   2            Seg_Buf[5] = Voltage_Input[3];
 100   2            // å½“å‰è¾“å…¥ä½é—ªçƒï¼ˆåªåœ¨æœªè¾“å…¥æ»¡4ä½æ—¶é—ªçƒï¼‰é‡è¦ï¼ï¼ï¼
 101   2            if(Voltage_Input_Index < 4 && Input_Flag == 1)
 102   2            {
 103   3              Seg_Buf[Voltage_Input_Index + 2] = 10;
 104   3            }
 105   2          break;
 106   2          case 1:
 107   2            Seg_Buf[0] = 14;
 108   2            Seg_Buf[1] = 10;
 109   2            Seg_Buf[2] = 10;
 110   2            Seg_Buf[3] = Voltage_Data[0];
 111   2            Seg_Point[3] = 1;
 112   2            Seg_Buf[4] = Voltage_Data[1];
 113   2            Seg_Buf[5] = Voltage_Data[2];
 114   2            if(Voltage_Data[3] >= 5)  Seg_Buf[5] = Voltage_Data[2] + 1;
 115   2            
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2026 00:37:41 PAGE 3   

 116   2            
 117   2          break;
 118   2          case 2:
 119   2            
 120   2          break;
 121   2          case 3:
 122   2            
 123   2          break;
 124   2            
 125   2          
 126   2        }
 127   1        
 128   1      }
 129          
 130          
 131          
 132          
 133          /* å…¶ä»–æ˜¾ç¤ºå‡½æ•° */
 134          void Led_Proc()
 135          {
 136   1        
 137   1      }
 138          
 139          
 140          
 141          
 142          /* å®šæ—¶å™¨0ä¸­æ–­åˆå§‹åŒ–å‡½æ•° */
 143          void Timer0Init(void)   //1æ¯«ç§’@12.000MHz
 144          {
 145   1        TMOD &= 0xF0;   //è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 146   1        TMOD |= 0x01;   //è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 147   1        TL0 = 0x18;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 148   1        TH0 = 0xFC;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 149   1        TF0 = 0;    //æ¸…é™¤TF0æ ‡å¿—
 150   1        TR0 = 1;    //å®šæ—¶å™¨0å¼€å§‹è®¡æ—¶
 151   1        ET0 = 1;    //å®šæ—¶å™¨0ä¸­æ–­æ‰“å¼€
 152   1        EA = 1;     //æ€»ä¸­æ–­æ‰“å¼€
 153   1      }
 154          
 155          
 156          /* å®šæ—¶å™¨0ä¸­æ–­æœåŠ¡å‡½æ•° */
 157          void Timer0Server() interrupt 1
 158          {
 159   1        TL0 = 0x18;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 160   1        TH0 = 0xFC;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼   
 161   1        if(++Key_Slow_Down == 10) Key_Slow_Down = 0;//é”®ç›˜å‡é€Ÿä¸“ç”¨
 162   1        if(++Seg_Slow_Down == 50) Seg_Slow_Down = 0;//æ•°ç ç®¡å‡é€Ÿä¸“ç”¨
 163   1        if(++Seg_Pos == 6) Seg_Pos = 0;//æ•°ç ç®¡æ˜¾ç¤ºä¸“ç”¨
 164   1        Seg_Disp(Seg_Pos, Seg_Buf[Seg_Pos], Seg_Point[Seg_Pos]);
 165   1        if (++ Timer250 == 250)
 166   1        {
 167   2          Timer250 = 0;
 168   2          Input_Flag ^= 1;
 169   2        }
 170   1        
 171   1        
 172   1        
 173   1          
 174   1      
 175   1        
 176   1      }
 177          
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2026 00:37:41 PAGE 4   

 178          /* Main */
 179          void main()
 180          {
 181   1        Timer0Init();
 182   1        while (1)
 183   1        {
 184   2          Key_Proc();
 185   2          Seg_Proc();
 186   2          Led_Proc();
 187   2        }
 188   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    427    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     35    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
