C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2026 22:43:54 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keilc51\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* å¤´æ–‡ä»¶å£°æ˜åŒº */
   2          #include <REGX52.H>//å•ç‰‡æœºå¯„å­˜å™¨ä¸“ç”¨å¤´æ–‡ä»¶
   3          #include <Key.h>//æŒ‰é”®åº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
   4          #include <Seg.h>//æ•°ç ç®¡åº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
   5          #include <intrins.h>
   6          #include <Led.h>
   7          /* å˜é‡å£°æ˜åŒº */
   8          unsigned char Key_Val,Key_Down,Key_Old,Key_Up;//æŒ‰é”®ä¸“ç”¨å˜é‡
   9          unsigned char Key_Slow_Down;//æŒ‰é”®å‡é€Ÿä¸“ç”¨å˜é‡
  10          unsigned char Seg_Buf[6] = {10,10,13,13,13,13};//æ•°ç ç®¡æ˜¾ç¤ºæ•°æ®å­˜æ”¾æ•°ç»„
  11          unsigned char Seg_Point[6] = {0,0,0,0,0,0};//æ•°ç ç®¡å°æ•°ç‚¹æ•°æ®å­˜æ”¾æ•°ç»„
  12          unsigned char Seg_Pos;//æ•°ç ç®¡æ‰«æä¸“ç”¨å˜é‡
  13          unsigned int  Seg_Slow_Down;//æ•°ç ç®¡å‡é€Ÿä¸“ç”¨å˜é‡
  14          unsigned char Disp_Mode = 0;//æ•°ç ç®¡æ˜¾ç¤ºæ¨¡å¼ï¼š0-ç”µå‹é‡‡é›†  1-æ•°æ®æ˜¾ç¤º  2-å‚æ•°è®¾ç½® 3-è®¡æ•
             -°ç»Ÿè®¡
  15          unsigned char Voltage_Input [4] ={13,13,13,13};//ç”µå‹è¾“å…¥æ•°ç»„
  16          unsigned char Voltage_Data [4] ={0,0,0,0};//ç”µå‹é‡‡é›†æ•°æ®æ•°ç»„
  17          unsigned char Voltage_Input_Index;//ç”µå‹æ•°æ®è¾“å…¥ç´¢å¼•
  18          unsigned char Voltage_Data_Index;//ç”µå‹æ•°æ®ç´¢å¼•
  19          unsigned int  Timer250;//500msé—ªçƒè®¡æ—¶
  20          bit Input_Flag;//é—ªçƒæ ‡å¿—ä½
  21          unsigned char Voltage_Val;//è¾“å…¥ç”µå‹å€¼
  22          unsigned char Key_Error_Count;//æŒ‰é”®æº¢å‡ºå˜é‡
  23          unsigned char Voltage_Setting_Data [3] ={3,0,0};//ç”µå‹å‚æ•°è®¾ç½®æ•°ç»„
  24          unsigned char Voltage_Setting;//ç”µå‹è®¾ç½®
  25          unsigned char Voltage_Setting_Data_Index;//ç”µå‹å‚æ•°è®¾ç½®æ•°ç»„ç´¢å¼•
  26          unsigned char Voltage_Real_Data [3] = {0,0,0};//ç”µå‹å®é™…å€¼
  27          unsigned int  Voltage_Real;//ç”µå‹çœŸå®å€¼
  28          unsigned int  Voltage_Old;//ç”µå‹çœŸå®å€¼Old
  29          unsigned int  Voltage_Count;//ç”µå‹è®¡æ•°
  30          
  31          
  32          /* é”®ç›˜å¤„ç†å‡½æ•° */
  33          void Key_Proc()
  34          {
  35   1        unsigned char i;
  36   1        if (Key_Slow_Down) return;
  37   1        Key_Slow_Down = 1;//æŒ‰é”®å‡é€Ÿç¨‹åº
  38   1        
  39   1        Key_Val = Key_Read();//è¯»å–æŒ‰ä¸‹çš„é”®å€¼
  40   1        Key_Down = Key_Val & (Key_Val ^ Key_Old);//ä¸‹é™æ²¿
  41   1        Key_Up = Key_Old & (Key_Val ^ Key_Old);//ä¸Šå‡æ²¿
  42   1        
  43   1        Key_Old = Key_Val;//è¾…åŠ©æ‰«æ
  44   1        
  45   1        
  46   1        if(Disp_Mode == 0)
  47   1        {
  48   2          if(Voltage_Input_Index < 4)  // æ”¹ä¸º < 4ï¼Œé˜²æ­¢è¶Šç•Œ
  49   2          {
  50   3            if((Key_Down >= 1) && (Key_Down <= 10))
  51   3            {
  52   4              Voltage_Val = Key_Down - 1;
  53   4              Voltage_Input[Voltage_Input_Index] = Voltage_Val;
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2026 22:43:54 PAGE 2   

  54   4              Voltage_Input_Index ++;
  55   4              Key_Error_Count = 0;
  56   4            }else
  57   3            {
  58   4            Key_Error_Count ++;
  59   4            }
  60   3          }
  61   2      
  62   2          // æŒ‰é”®11ç¡®è®¤ï¼šç‹¬ç«‹åˆ¤æ–­ï¼Œä¸å—è¾“å…¥ç´¢å¼•é™åˆ¶
  63   2          if((Key_Down == 11) && (Voltage_Input_Index == 4) )
  64   2          {
  65   3            // 1. ä¿å­˜æ—§ç”µå‹å€¼ç”¨äºä¸‹é™æ²¿æ£€æµ‹
  66   3            Voltage_Old = Voltage_Real;
  67   3      
  68   3            // 2. å¤åˆ¶æ–°è¾“å…¥æ•°æ®
  69   3            for(i = 0;i<4;i++)
  70   3            {
  71   4              Voltage_Data[i] = Voltage_Input[i];
  72   4            }
  73   3      
  74   3            // 3. ç«‹å³è®¡ç®—å››èˆäº”å…¥å€¼ï¼ˆå¤åˆ¶Seg_Procæ¨¡å¼1çš„é€»è¾‘ï¼‰
  75   3            Voltage_Real_Data[0] = Voltage_Data[0];
  76   3            Voltage_Real_Data[1] = Voltage_Data[1];
  77   3            Voltage_Real_Data[2] = Voltage_Data[2];
  78   3            if(Voltage_Data[3] >= 5)  // ç¬¬4ä½å››èˆäº”å…¥
  79   3            {
  80   4              Voltage_Real_Data[2]++;
  81   4              if(Voltage_Real_Data[2] >= 10)
  82   4              {
  83   5                Voltage_Real_Data[2] = 0;
  84   5                Voltage_Real_Data[1]++;
  85   5              }
  86   4              if(Voltage_Real_Data[1] >= 10)
  87   4              {
  88   5                Voltage_Real_Data[1] = 0;
  89   5                Voltage_Real_Data[0]++;
  90   5              }
  91   4            }
  92   3            Voltage_Real = Voltage_Real_Data[2] + 10*Voltage_Real_Data[1] + 100*Voltage_Real_Data[0];
  93   3      
  94   3            // 4. ä¸‹é™æ²¿æ£€æµ‹ï¼šä¸Šæ¬¡>=é˜ˆå€¼ ä¸” å½“å‰<é˜ˆå€¼
  95   3            Voltage_Setting = Voltage_Setting_Data[2] + 10*Voltage_Setting_Data[1] + 100*Voltage_Setting_Data[0];
  96   3            if((Voltage_Real < Voltage_Setting) && (Voltage_Old >= Voltage_Setting))
  97   3            {
  98   4              Voltage_Count++;
  99   4            }
 100   3      
 101   3            Disp_Mode = 1;
 102   3          }
 103   2          
 104   2          
 105   2          if(Key_Down == 14)
 106   2          {
 107   3            if(Disp_Mode == 0)
 108   3            {
 109   4              Voltage_Input_Index = 0;
 110   4              for(i = 0;i<4;i++)
 111   4              {
 112   5              
 113   5                Voltage_Input[i] = 13;
 114   5              
 115   5              }
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2026 22:43:54 PAGE 3   

 116   4            }else if(Disp_Mode == 3)
 117   3            {
 118   4              Voltage_Count = 0;
 119   4            }
 120   3            
 121   3          }
 122   2        }else if(Key_Down == 11)  // éæ¨¡å¼0æ—¶æŒ‰S7è¿”å›æ¨¡å¼0
 123   1        {
 124   2          Voltage_Input_Index = 0;
 125   2          for(i = 0;i<4;i++)
 126   2          {
 127   3            Voltage_Input[i] = 13;
 128   3          }
 129   2          Disp_Mode = 0;
 130   2        }else if(Key_Down == 12)
 131   1        {
 132   2          if(++ Disp_Mode == 4) Disp_Mode = 1;
 133   2        }   
 134   1        
 135   1        if(Disp_Mode == 2)
 136   1        {
 137   2          if(Key_Down == 15)
 138   2          {
 139   3             Voltage_Setting_Data[1] += 5;
 140   3            if( Voltage_Setting_Data[1] == 10)  
 141   3            {
 142   4              Voltage_Setting_Data[1] = 0;
 143   4              Voltage_Setting_Data[0] += 1;
 144   4            }
 145   3            if((Voltage_Setting_Data[0] == 6) && (Voltage_Setting_Data[1] == 5))
 146   3            { 
 147   4              Voltage_Setting_Data[0] = 1;
 148   4              Voltage_Setting_Data[1] = 0;
 149   4            }
 150   3          }
 151   2          if(Key_Down == 16)
 152   2          {
 153   3            
 154   3            if( Voltage_Setting_Data[1] == 0) 
 155   3            {
 156   4              Voltage_Setting_Data[1] = 5;
 157   4              Voltage_Setting_Data[0] -= 1;
 158   4            }else
 159   3            {
 160   4              Voltage_Setting_Data[1] -= 5;
 161   4              
 162   4            }
 163   3            if((Voltage_Setting_Data[0] == 0) && (Voltage_Setting_Data[1] == 5))  
 164   3            {
 165   4              Voltage_Setting_Data[1] = 0;
 166   4              Voltage_Setting_Data[0] = 6;
 167   4            }
 168   3          }
 169   2        }
 170   1        
 171   1        
 172   1      }
 173          
 174          /* ä¿¡æ¯å¤„ç†å‡½æ•° */
 175          void Seg_Proc()
 176          {
 177   1        unsigned char i;
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2026 22:43:54 PAGE 4   

 178   1        if (Seg_Slow_Down) return;
 179   1        Seg_Slow_Down =1 ;
 180   1        switch(Disp_Mode)
 181   1        {
 182   2          case 0:
 183   2            Seg_Buf[0] = 10;
 184   2            Seg_Buf[1] = 10;
 185   2            // æ˜¾ç¤ºå·²è¾“å…¥çš„4ä½æ•°æ®
 186   2            
 187   2            Seg_Buf[2] = Voltage_Input[0];
 188   2            Seg_Buf[3] = Voltage_Input[1];
 189   2            Seg_Point[3] = 0;
 190   2            Seg_Buf[4] = Voltage_Input[2];
 191   2            Seg_Buf[5] = Voltage_Input[3];
 192   2            // å½“å‰è¾“å…¥ä½é—ªçƒï¼ˆåªåœ¨æœªè¾“å…¥æ»¡4ä½æ—¶é—ªçƒï¼‰é‡è¦ï¼ï¼ï¼
 193   2            if(Voltage_Input_Index < 4 && Input_Flag == 1)
 194   2            {
 195   3              Seg_Buf[Voltage_Input_Index + 2] = 10;
 196   3            }
 197   2          break;
 198   2          case 1:
 199   2            Seg_Buf[0] = 14;
 200   2            Seg_Buf[1] = 10;
 201   2            Seg_Buf[2] = 10;
 202   2            Seg_Buf[3] = Voltage_Data[0];
 203   2            Seg_Point[3] = 1;
 204   2            Seg_Buf[4] = Voltage_Data[1];
 205   2            Seg_Buf[5] = Voltage_Data[2];
 206   2            if(Voltage_Data[3] >= 5)  
 207   2            {
 208   3              Seg_Buf[5] = Voltage_Data[2] + 1;
 209   3            }
 210   2            if(Seg_Buf[5] >= 10)
 211   2            {
 212   3              Seg_Buf[5] = 0;
 213   3              Seg_Buf[4] = Voltage_Data[1] + 1;
 214   3            }
 215   2            if(Seg_Buf[4] >= 10)
 216   2            {
 217   3              Seg_Buf[4] = 0;
 218   3              Seg_Buf[3] = Voltage_Data[0] + 1;
 219   3            }
 220   2            if(Seg_Buf[3] == 10)
 221   2            {
 222   3              Seg_Buf[3] = 0;
 223   3              Seg_Buf[2] = 1;
 224   3            }
 225   2          
 226   2          break;
 227   2          case 2:
 228   2            Seg_Buf[0] = 15;
 229   2            Seg_Buf[1] = 10;
 230   2            Seg_Buf[2] = 10;
 231   2            Seg_Buf[3] = Voltage_Setting_Data[0];
 232   2            Seg_Point[3] = 1;
 233   2            Seg_Buf[4] = Voltage_Setting_Data[1];
 234   2            Seg_Buf[5] = Voltage_Setting_Data[2];
 235   2          break;
 236   2          case 3:
 237   2            Seg_Buf[0] =  16; 
 238   2            Seg_Buf[1] =  Voltage_Count / 10000 %10;
 239   2            Seg_Buf[2] =  Voltage_Count / 1000 %10;
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2026 22:43:54 PAGE 5   

 240   2            Seg_Buf[3] =  Voltage_Count / 100 %10;
 241   2            Seg_Point[3] = 0;
 242   2            Seg_Buf[4] =  Voltage_Count / 10 %10;
 243   2            Seg_Buf[5] =  Voltage_Count %10;
 244   2            for(i= 0;i<5;i++)
 245   2            {
 246   3              if(Seg_Buf[i] == 0) Seg_Buf[i] = 10;
 247   3            }
 248   2          
 249   2          break;
 250   2            
 251   2          
 252   2        }
 253   1        
 254   1      }
 255          
 256          
 257          
 258          
 259          /* å…¶ä»–æ˜¾ç¤ºå‡½æ•° */
 260          void Led_Proc()
 261          {
 262   1        
 263   1      }
 264          
 265          
 266          
 267          
 268          /* å®šæ—¶å™¨0ä¸­æ–­åˆå§‹åŒ–å‡½æ•° */
 269          void Timer0Init(void)   //1æ¯«ç§’@12.000MHz
 270          {
 271   1        TMOD &= 0xF0;   //è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 272   1        TMOD |= 0x01;   //è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 273   1        TL0 = 0x18;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 274   1        TH0 = 0xFC;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 275   1        TF0 = 0;    //æ¸…é™¤TF0æ ‡å¿—
 276   1        TR0 = 1;    //å®šæ—¶å™¨0å¼€å§‹è®¡æ—¶
 277   1        ET0 = 1;    //å®šæ—¶å™¨0ä¸­æ–­æ‰“å¼€
 278   1        EA = 1;     //æ€»ä¸­æ–­æ‰“å¼€
 279   1      }
 280          
 281          
 282          /* å®šæ—¶å™¨0ä¸­æ–­æœåŠ¡å‡½æ•° */
 283          void Timer0Server() interrupt 1
 284          {
 285   1        TL0 = 0x18;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 286   1        TH0 = 0xFC;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼   
 287   1        if(++Key_Slow_Down == 10) Key_Slow_Down = 0;//é”®ç›˜å‡é€Ÿä¸“ç”¨
 288   1        if(++Seg_Slow_Down == 50) Seg_Slow_Down = 0;//æ•°ç ç®¡å‡é€Ÿä¸“ç”¨
 289   1        if(++Seg_Pos == 6) Seg_Pos = 0;//æ•°ç ç®¡æ˜¾ç¤ºä¸“ç”¨
 290   1        Seg_Disp(Seg_Pos, Seg_Buf[Seg_Pos], Seg_Point[Seg_Pos]);
 291   1        if (++ Timer250 == 250)
 292   1        {
 293   2          Timer250 = 0;
 294   2          Input_Flag ^= 1;
 295   2        }
 296   1        
 297   1        
 298   1        
 299   1          
 300   1      
 301   1        
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2026 22:43:54 PAGE 6   

 302   1      }
 303          
 304          /* Main */
 305          void main()
 306          {
 307   1        Timer0Init();
 308   1        while (1)
 309   1        {
 310   2          
 311   2          Key_Proc();
 312   2          Seg_Proc();
 313   2          Led_Proc();
 314   2        }
 315   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    980    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     49       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
