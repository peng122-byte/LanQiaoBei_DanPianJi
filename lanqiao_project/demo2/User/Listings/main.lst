C51 COMPILER V9.59.0.0   MAIN                                                              01/21/2026 20:05:02 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keilc51\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* 头文件声明区 */
   2          #include <REGX52.H>//单片机寄存器专用头文件
   3          #include <Key.h>//按键底层驱动专用头文件
   4          #include <Seg.h>//数码管底层驱动专用头文件
   5          
   6          /* 变量声明区 */
   7          unsigned char Key_Val,Key_Down,Key_Old;//按键专用变量
   8          unsigned char Key_Slow_Down;//按键减速专用变量
   9          unsigned char Seg_Buf[6] = {10,10,10,10,10,10};//数码管显示数据存放数组
  10          unsigned char Seg_Buf_Point[6] = {0,1,0,1,0,1};//显示小数点
  11          unsigned char Seg_Pos;//数码管扫描专用变量
  12          unsigned int Seg_Slow_Down;//数码管减速专用变量
  13          unsigned char Alarm_Set_Buf[3] = {0,0,0};//闹钟设置数组
  14          unsigned char Alarm_Index;//闹钟设置数组索引
  15          unsigned char Time[3] = {23,59,55};//时钟设置数组
  16          unsigned char Time_Index ;//时钟设置数组索引
  17          unsigned char Hour=23,Minute=59,Second=55;//时分秒
  18          unsigned char Clock_Mode;//0--时钟显示  1--时钟设置 2--闹钟设置
  19          unsigned int Timer250;//0.5秒闪烁
  20          bit Flag500;//0.5秒闪烁标志位
  21          unsigned int Timer1000;//一秒计时
  22          bit TimeFlag = 0;//时间到标志位
  23          /* 键盘处理函数 */
  24          void Key_Proc()
  25          {
  26   1        if(Key_Slow_Down) return;
  27   1        Key_Slow_Down = 1;//键盘减速程序
  28   1      
  29   1        Key_Val = Key_Read();//实时读取键码值
  30   1        Key_Down = Key_Val & (Key_Old ^ Key_Val);//捕捉按键下降沿
  31   1        Key_Old = Key_Val;//辅助扫描变量
  32   1        if(Key_Down) TimeFlag = 0;
  33   1      
  34   1        switch(Key_Down)
  35   1        {
  36   2          case 1:
  37   2            if (Clock_Mode == 0) 
  38   2            {
  39   3              Time[0] = Hour;
  40   3              Time[1] = Minute;
  41   3              Time[2] = Second;
  42   3              Clock_Mode = 1;
  43   3            }
  44   2            break;
  45   2          case 2:
  46   2            if (Clock_Mode == 0) Clock_Mode = 2;
  47   2            break;
  48   2          case 3:
  49   2            if(Clock_Mode == 1)
  50   2            {
  51   3              if( ++Time_Index == 3) Time_Index = 0;
  52   3            }
  53   2            if(Clock_Mode == 2)
  54   2            {
C51 COMPILER V9.59.0.0   MAIN                                                              01/21/2026 20:05:02 PAGE 2   

  55   3              if( ++Alarm_Index == 3) Alarm_Index = 0;
  56   3            }
  57   2            break;
  58   2          case 4:
  59   2            
  60   2            break;
  61   2          case 5:
  62   2            if(Clock_Mode == 1)
  63   2            {
  64   3              if(Time_Index == 0)
  65   3              {
  66   4                if(++ Time[Time_Index] == 24) Time[Time_Index] = 0;
  67   4              }else
  68   3              {
  69   4                if(++ Time[Time_Index] == 60) Time[Time_Index] = 0;
  70   4              }
  71   3              
  72   3            }
  73   2            if(Clock_Mode == 2)
  74   2            {
  75   3              if(Time_Index == 0)
  76   3              {
  77   4                if(++ Alarm_Set_Buf[Alarm_Index] == 24) Alarm_Set_Buf[Alarm_Index] = 0;
  78   4              }else
  79   3              {
  80   4                if(++ Alarm_Set_Buf[Alarm_Index] == 60) Alarm_Set_Buf[Alarm_Index] = 0;
  81   4              }
  82   3              
  83   3            }
  84   2            
  85   2            break;
  86   2          case 6:
  87   2            if(Clock_Mode == 1)
  88   2            {
  89   3              if(Time_Index == 0)
  90   3              {
  91   4                if(-- Time[Time_Index] == 255)  Time[Time_Index] = 23;
  92   4              }else
  93   3              {
  94   4                if(-- Time[Time_Index] == 255)  Time[Time_Index] = 59;
  95   4              }
  96   3              
  97   3            }
  98   2            if(Clock_Mode == 2)
  99   2            {
 100   3              if(Time_Index == 0)
 101   3              {
 102   4                if(-- Alarm_Set_Buf[Alarm_Index] == 255) Alarm_Set_Buf[Alarm_Index] = 23;
 103   4              }else
 104   3              {
 105   4                if(-- Alarm_Set_Buf[Alarm_Index] == 255)  Alarm_Set_Buf[Alarm_Index] = 59;
 106   4              }
 107   3              
 108   3            }
 109   2            
 110   2            break;
 111   2          case 7:
 112   2            if(Clock_Mode == 1)
 113   2            {
 114   3              Hour = Time[0];
 115   3              Minute = Time[1];
 116   3              Second = Time[2];
C51 COMPILER V9.59.0.0   MAIN                                                              01/21/2026 20:05:02 PAGE 3   

 117   3              Clock_Mode = 0;
 118   3            }
 119   2            if(Clock_Mode == 2)
 120   2            {
 121   3              Clock_Mode = 0;
 122   3            }
 123   2            break;
 124   2          case 8:
 125   2            if(Clock_Mode == 1)
 126   2            {
 127   3              Clock_Mode = 0;
 128   3              Time[0] = Hour;
 129   3              Time[1] = Minute;
 130   3              Time[2] = Second;
 131   3            }
 132   2            if(Clock_Mode == 2)
 133   2            {
 134   3              Clock_Mode = 0;
 135   3              Alarm_Set_Buf[0] = 0;
 136   3              Alarm_Set_Buf[1] = 0;
 137   3              Alarm_Set_Buf[2] = 0;
 138   3            }
 139   2            break;
 140   2        }
 141   1      }
 142          
 143          /* 信息处理函数 */
 144          void Seg_Proc()
 145          {
 146   1        if(Seg_Slow_Down) return;
 147   1        Seg_Slow_Down = 1;//数码管减速程序
 148   1      
 149   1        if( Clock_Mode == 0 )
 150   1        {
 151   2          Seg_Buf[0] = Hour /10 %10;
 152   2          Seg_Buf[1] = Hour %10;
 153   2          Seg_Buf[2] = Minute /10 %10;
 154   2          Seg_Buf[3] = Minute %10;
 155   2          Seg_Buf[4] = Second /10 %10;
 156   2          Seg_Buf[5] = Second %10;
 157   2        }
 158   1        if( Clock_Mode == 1 )
 159   1        {
 160   2          if( Flag500 == 0)
 161   2          {
 162   3            Seg_Buf[2*Time_Index] = 10;
 163   3            Seg_Buf[1+2*Time_Index] = 10;
 164   3          }else
 165   2          {
 166   3          Seg_Buf[0] = Time[0] /10 %10;
 167   3          Seg_Buf[1] = Time[0] %10;
 168   3          Seg_Buf[2] = Time[1] /10 %10;
 169   3          Seg_Buf[3] = Time[1] %10;
 170   3          Seg_Buf[4] = Time[2] /10 %10;
 171   3          Seg_Buf[5] = Time[2] %10;
 172   3          }
 173   2        }
 174   1        if( Clock_Mode == 2 )
 175   1        {
 176   2          if( Flag500 == 0)
 177   2          {
 178   3            Seg_Buf[2*Alarm_Index] = 10;
C51 COMPILER V9.59.0.0   MAIN                                                              01/21/2026 20:05:02 PAGE 4   

 179   3            Seg_Buf[1+2*Alarm_Index] = 10;
 180   3          }else
 181   2          {
 182   3          Seg_Buf[0] = Alarm_Set_Buf[0] /10 %10;
 183   3          Seg_Buf[1] = Alarm_Set_Buf[0] %10;
 184   3          Seg_Buf[2] = Alarm_Set_Buf[1] /10 %10;
 185   3          Seg_Buf[3] = Alarm_Set_Buf[1] %10;
 186   3          Seg_Buf[4] = Alarm_Set_Buf[2] /10 %10;
 187   3          Seg_Buf[5] = Alarm_Set_Buf[2] %10;
 188   3          }
 189   2        }
 190   1      }
 191          
 192          /* 其他显示函数 */
 193          void Led_Proc()
 194          {
 195   1        if( (Hour == Alarm_Set_Buf[0]) && (Minute == Alarm_Set_Buf[1]) && (Second == Alarm_Set_Buf[2])) TimeFlag 
             -= 1;
 196   1        if(TimeFlag)
 197   1        {
 198   2          P2_3 = 0;
 199   2          if( Alarm_Set_Buf[0] < 12)
 200   2          {
 201   3            if( Flag500 == 0)
 202   3            {
 203   4              P1 ^= 0xF0;
 204   4            }
 205   3          }
 206   2          if( (Alarm_Set_Buf[0] > 12) || ((Alarm_Set_Buf[0] == 12) && (Alarm_Set_Buf[1]>= 0)) || ((Alarm_Set_Buf[0
             -] == 12) && (Alarm_Set_Buf[1] == 0) && (Alarm_Set_Buf[2]>= 0)))
 207   2          {
 208   3              if( Flag500 == 0)
 209   3            {
 210   4              P1 ^= 0x0F;
 211   4            }
 212   3          }
 213   2        }else
 214   1        {
 215   2          P2_3 = 1;
 216   2          P1 = 0xFF;
 217   2        }
 218   1      }
 219          
 220          /* 定时器0中断初始化函数 */
 221          void Timer0Init(void)   //1毫秒@12.000MHz
 222          {
 223   1        TMOD &= 0xF0;   //设置定时器模式
 224   1        TMOD |= 0x01;   //设置定时器模式
 225   1        TL0 = 0x18;   //设置定时初始值
 226   1        TH0 = 0xFC;   //设置定时初始值
 227   1        TF0 = 0;    //清除TF0标志
 228   1        TR0 = 1;    //定时器0开始计时
 229   1        ET0 = 1;        //定时器0中断打开
 230   1        EA = 1;         //总中断打开
 231   1      }
 232          
 233          /* 定时器0中断服务函数 */
 234          void Timer0Server() interrupt 1
 235          {
 236   1        TL0 = 0x18;   //设置定时初始值
 237   1        TH0 = 0xFC;   //设置定时初始值   
 238   1        if(++Key_Slow_Down == 10) Key_Slow_Down = 0;//键盘减速专用
C51 COMPILER V9.59.0.0   MAIN                                                              01/21/2026 20:05:02 PAGE 5   

 239   1        if(++Seg_Slow_Down == 50) Seg_Slow_Down = 0;//数码管减速专用
 240   1        if(++Seg_Pos == 6) Seg_Pos = 0;//数码管显示专用
 241   1        Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Buf_Point[Seg_Pos]);
 242   1        if(++Timer250 == 250) 
 243   1        {
 244   2          Timer250 = 0;
 245   2          Flag500 ^= 1;
 246   2        }
 247   1        if(++Timer1000 == 1000) 
 248   1        {
 249   2          Timer1000 = 0;
 250   2          if(++ Second == 60) 
 251   2          {
 252   3            Second = 0;
 253   3            if(++Minute == 60)
 254   3            {
 255   4              Minute = 0;
 256   4              if(++ Hour == 24) Hour = 0;
 257   4            }
 258   3          }
 259   2        }
 260   1      }
 261          
 262          /* Main */
 263          void main()
 264          {
 265   1        Timer0Init();
 266   1        while (1)
 267   1        {
 268   2          Key_Proc();
 269   2          Seg_Proc();
 270   2          Led_Proc();
 271   2        }
 272   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1003    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     35    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
