# onewire.c 代码逻辑分析

这是一个 **DS18B20 温度传感器** 的单线（OneWire）通信协议驱动程序，用于51单片机。下面是详细的代码逻辑分析：

---

## 📌 **1. 全局定义**
```c
sbit DQ = P1^4;  // 定义单线数据引脚为P1.4
```
- DQ（Data Query）是DS18B20的单线通信引脚

---

## 🕒 **2. Delay_OneWire() - 内部延时函数**
```c
void Delay_OneWire(unsigned int t)
{
    while(t--);  // 简单的循环延时
}
```
**作用：** 提供微秒级的时序延时，确保单线协议时序正确

---

## ✍️ **3. Write_DS18B20() - 写入一个字节**
```c
void Write_DS18B20(unsigned char dat)
{
    unsigned char i;
    for(i=0; i<8; i++)  // 逐位发送8位数据
    {
        DQ = 0;              // 1. 拉低总线开始写时隙
        DQ = dat & 0x01;     // 2. 写入当前位(LSB先发)
        Delay_OneWire(5);    // 3. 保持时隙时间
        DQ = 1;              // 4. 释放总线
        dat >>= 1;           // 5. 右移准备下一位
    }
    Delay_OneWire(5);
}
```
**时序逻辑：**
- **写0：** 拉低60μs以上，然后释放
- **写1：** 拉低后立即释放（由上拉电阻拉高）
- 每个位按 **LSB（最低位）先发** 的顺序传输

---

## 📖 **4. Read_DS18B20() - 读取一个字节**
```c
unsigned char Read_DS18B20(void)
{
    unsigned char i;
    unsigned char dat;
    for(i=0; i<8; i++)  // 逐位读取8位数据
    {
        DQ = 0;              // 1. 拉低总线启动读时隙
        dat >>= 1;           // 2. 数据右移准备接收
        DQ = 1;              // 3. 释放总线让传感器响应
        if(DQ)               // 4. 读取引脚电平
        {
            dat |= 0x80;     // 5. 如果是高电平，设置最高位为1
        }
        Delay_OneWire(5);    // 6. 等待读时隙结束
    }
    return dat;
}
```
**时序逻辑：**
- 拉低1μs启动读时隙
- 释放总线后15μs内采样数据线
- 按 **LSB先读** 顺序接收，通过右移和置位操作重组字节

---

## 🔧 **5. init_ds18b20() - 初始化传感器**
```c
bit init_ds18b20(void)
{
    bit initflag = 0;

    DQ = 1;                  // 1. 释放总线
    Delay_OneWire(12);       // 2. 总线空闲
    DQ = 0;                  // 3. 拉低总线480μs(复位脉冲)
    Delay_OneWire(80);
    DQ = 1;                  // 4. 释放总线
    Delay_OneWire(10);       // 5. 等待DS18B20应答
    initflag = DQ;           // 6. 读取应答信号(0=成功,1=失败)
    Delay_OneWire(5);

    return initflag;
}
```
**初始化握手流程：**
1. 主机发送 **480-960μs** 复位脉冲（拉低总线）
2. 释放总线后等待 **15-60μs**
3. DS18B20拉低总线 **60-240μs** 作为应答
4. **返回值为0表示初始化成功**，为1表示无设备响应

---

## 🌡️ **6. read_t() - 读取温度值**
```c
float read_t()
{
    unsigned char low, high;

    // 第一次通信：启动温度转换
    init_ds18b20();          // 初始化
    Write_DS18B20(0xcc);     // 跳过ROM命令(单总线单设备)
    Write_DS18B20(0x44);     // 启动温度转换命令

    // 第二次通信：读取温度数据
    init_ds18b20();          // 重新初始化
    Write_DS18B20(0xcc);     // 跳过ROM命令
    Write_DS18B20(0xbe);     // 读暂存器命令
    low = Read_DS18B20();    // 读温度低字节
    high = Read_DS18B20();   // 读温度高字节

    return ((high << 8) | low) / 16.0;  // 合并并转换为摄氏度
}
```

**DS18B20 命令详解：**
- **0xCC：** SKIP ROM（跳过ROM匹配，适用于单设备）
- **0x44：** CONVERT T（启动温度转换）
- **0xBE：** READ SCRATCHPAD（读取暂存器数据）

**温度计算：**
- DS18B20返回16位温度数据（12位分辨率）
- 低4位是小数部分，每LSB = 0.0625°C
- **除以16.0** 得到实际温度值（°C）

---

## 🔍 **协议总结**

| 功能 | 时序特点 |
|------|---------|
| **初始化** | 480μs复位脉冲 + 等待应答 |
| **写入** | 每位1μs拉低 + 数据保持 + 释放 |
| **读取** | 1μs拉低 + 15μs内采样 |

**典型使用流程：**
```
初始化 → 跳过ROM(0xCC) → 启动转换(0x44) → 等待 →
初始化 → 跳过ROM(0xCC) → 读数据(0xBE) → 接收温度
```

---

## 📝 **注意事项**

1. **时序精度要求高：** 单线协议对时序敏感，延时函数需根据MCU频率调整
2. **上拉电阻：** DQ引脚需外接4.7KΩ上拉电阻
3. **温度转换时间：** 0x44命令后需等待至少750ms（12位分辨率）
4. **多设备应用：** 如需挂载多个DS18B20，需使用ROM匹配命令（0x55）代替0xCC

---

## 🎯 **应用场景**

这个驱动实现了DS18B20的基本通信协议，适用于：
- 蓝桥杯单片机竞赛的温度采集应用
- 环境温度监测系统
- 温控设备开发
- 多点温度测量（需扩展ROM匹配功能）
